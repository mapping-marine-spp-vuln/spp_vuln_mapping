---
title: "Map AquaMaps species to Mollweide from HCAF"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      echo = TRUE, message = FALSE, warning = FALSE)

library(oharac) ### remotes::install_github('oharac/oharac')
library(raster)
library(tidyverse)
library(here)
source(here('common_fxns.R'))

```

# Summary

Convert HCAF maps from AquaMaps into the Mollweide 10 km x 10 km projection.

# Methods

For each species, bind the AquaMaps HCAF cell presence values with a lookup dataframe of LOICZID to Mollweide cell ID.  Save out a vector of just the new Mollweide ID cell values, per species (rather than per AquaMaps species ID).

```{r create cell id lookup}
loiczid_mol_r <- raster(here('_spatial/loiczid_mol.tif'))
ocean_mol_r <- raster(here('_spatial/ocean_area_mol.tif'))
bathy_mol_neritic <- raster(here('_spatial/bathy_mol_neritic.tif'))
bathy_mol_shallow <- raster(here('_spatial/bathy_mol_shallow.tif'))

cell_id_df <- data.frame(loiczid = values(loiczid_mol_r),
                         ocean_a = values(ocean_mol_r),
                         neritic = values(bathy_mol_neritic),
                         shallow = values(bathy_mol_shallow),
                         cell_id = 1:ncell(loiczid_mol_r)) %>%
  filter(!is.na(ocean_a))
```

```{r load am data}

am_spp_cells <- get_am_spp_cells()

wcol_position <- read_csv(here('_data/traits_grouping/trait_water_col_position.csv')) %>%
  select(sciname = species, wcol_pos = value) %>%
  distinct()

am_spp_info <- get_am_spp_info() %>%
  oharac::dt_join(get_am_spp_envelopes(), by = 'am_sid', type = 'left') %>%
  oharac::dt_join(wcol_position, by = 'sciname', type = 'left') %>%
  filter(param == 'log10_depth') %>%
  # mutate(value = 10^value) %>%
  spread(dist, value) %>%
  mutate(am_sid = tolower(am_sid),
         mask   = case_when(str_detect(wcol_pos, 'pelagic') ~ 'none', ### don't clip pelagics
                            is.na(wcol_pos)                 ~ 'none', ### don't clip unknowns
                            max <=  60 ~ 'shallow',
                            max <= 200 ~ 'neritic',
                            TRUE       ~ 'none')) %>%
  mutate(mask = factor(mask, levels = c('shallow', 'neritic', 'none'), ordered = TRUE)) %>%
  select(am_sid, sciname, mask)

# x <- am_spp_info %>%
#   filter(is.na(wcol_pos)) %>%
#   mutate(f = sprintf(map_fstem, str_replace_all(sciname, ' ', '_')))
```

``` {r process maps}
map_fstem <- here_anx('spp_maps_mol', 'am_spp_mol_%s.csv')

x <- list.files(dirname(map_fstem), pattern = 'am_spp_mol', full.names = TRUE)
spp_done <- basename(x) %>% str_remove_all('am_spp_mol_|.csv$') %>%
  str_replace_all('[^a-z]+', ' ')

spp_vec <- am_spp_info %>%
  filter(!is.na(sciname)) %>%
  filter(!sciname %in% spp_done) %>%
  .$sciname %>% unique() %>% sort()


map_am_hcaf_to_moll <- function(s) {
  # s <- spp_vec[1]
  i <- which(spp_vec == s)
  
  out_f <- sprintf(map_fstem, str_replace_all(s, ' ', '_'))
  if(!file.exists(out_f)) {
    message('Processing map for ', s, '... (', i, ' of ', length(spp_vec), ')')
    
    ### identify the species ID(s) for this species
    s_sids <- am_spp_info %>% 
      filter(sciname == s) %>%
      .$am_sid %>% unique()
    
    ### identify the depth(s); if multiple, choose the least restrictive
    s_depth <- am_spp_info %>% 
      filter(sciname == s) %>%
      filter(mask == max(mask)) %>%
      .$mask %>% unique()
    
    ### identify the cells for am_sid(s) and join to Mollweide cells
    s_cells <- am_spp_cells %>%
      filter(am_sid %in% s_sids)
    s_mol <- s_cells %>%
      oharac::dt_join(cell_id_df, by = 'loiczid', type = 'left')
    
    ### filter to proper depth category
    if(s_depth == 'shallow') {
      message('... clipping ', s, ' to shallow waters only')
      s_mol <- s_mol %>%
        filter(!is.na(shallow))
    } else if(s_depth == 'neritic') {
      message('... clipping ', s, ' to neritic waters only')
      s_mol <- s_mol %>%
        filter(!is.na(neritic))
    } ### else, 'none', so no bathymetric filter
    
    s_mol <- s_mol %>%
      select(prob, cell_id)
    write_csv(s_mol, out_f)
  }
}

tmp <- parallel::mclapply(spp_vec, map_am_hcaf_to_moll, mc.cores = 12)
```

