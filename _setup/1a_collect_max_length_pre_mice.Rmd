---
title: "Collect length/body size trait"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(oharac)
oharac::setup()
library(rfishbase)
source(here('common_fxns.R'))

```

# Summary

Gather data on body length from FishBase and the species vulnerability project.  Gapfill using downfill and upstream-downstream gapfill methodology.

# Data

This script will use processed valid species traits from the species vulnerability project, plus FishBase and SeaLifeBase.

FishBase is a scientific database, and this has the implication - among others - that its use and the use of its contents are free as long as due credit is given.

This may be done at different levels, for which we suggest different forms of citations:

* when referring to FishBase concepts and design, cite its architects (Froese and Pauly 2000);
* when referring to a set of values extracted from a FishBase table, cite the author(s) of the original data, e.g., "Houde and Zastrow (1993)", or "Welcomme (1988)". To help us track the use of FishBase in the literature, we would appreciate your also citing Froese and Pauly (2000) in an appropriate part of your text, as the source of the information;
* when discussing the features of a FishBase table, cite the section documenting that table, e.g., "Sa-a et al. (2000)."

## References

* Froese, R. and D. Pauly, Editors. 2000. FishBase 2000: concepts, design and data sources. ICLARM, Los Baños, Laguna, Philippines. 344 p.
* Houde, E.D. and C.E. Zastrow. 1993. Ecosystem- and taxon-specific dynamic energetics properties of fish larvae assemblages. Bull. Mar. Sci. 53(2):290-335.
* Sa-a, P., M.L. Palomares and D. Pauly. 2000. The FOOD ITEMS table, p. 182-188. In R. Froese and D. Pauly (eds.) FishBase 2000: concepts, design and data sources. ICLARM, Los Baños, Laguna, Philippines. 344 p.
* Welcomme, R.L. 1988. International introductions of inland aquatic species. FAO Fish. Tech. Pap. 294, 318 p.
* Butt, N. et al. 2021. 

# Methods

## Read in data

Read in data from vulnerability project and fishbase/sealifebase

```{r}
length_vuln <- get_vuln_traits() %>%
  filter(trait == 'adult_body_mass_body_size') %>%
  mutate(trait_value = factor(trait_value, 
                              levels = c('0.5mm-49mm', '50mm-999mm', '>1000mm')),
         bin = as.integer(trait_value))
         
keep_cols <- c('f_bname', 'length')
length_fb_raw <- get_fb_slb(fxn = species, 
                            keep_cols = keep_cols, keep_fxn = contains,
                            drop_cols = '_ref',    drop_fxn = ends_with)

length_fb_num <- length_fb_raw %>%
  mutate(across(contains('length'), ~ as.numeric(.x)),
         spec_code = as.integer(spec_code))
```

### gapfill `length` using regression on other length traits

Because the FishBase/SeaLifeBase species contains multiple columns with length information, use that to help gapfill species where `length` data is NA but `common_length` or `length_female` is not NA.  First remove the outlier of common length = 916000 (_Dermochelys coriacea_ are not nine kilometers long)

```{r}
length_df_outlier_removed <- length_fb_num %>%
  filter(common_length < 2500)
ggplot(length_df_outlier_removed %>%
         gather(fill_trait, val, common_length, length_female), aes(x = length, y = val, color = fill_trait)) +
  geom_point() +
  geom_smooth(method = 'lm')

x <- lm(common_length ~ length, data = length_df_outlier_removed)

y <- lm(length_female ~ length, data = length_fb_num)

l_c_coeff <- x$coefficients[2]
l_f_coeff <- y$coefficients[2]
```

`common_length ~ length` shows intercept of less than 2 cm, coefficient of .54, with p < 2e-16 and R^2^ of 86%.  This has strong potential to gapfill max length to gain an additional ~300 spp.

`length_female ~ length` shows an intercept of 3 cm, a coefficient of .89, with highly significant p values and R^2^ around 92%.  This has strong potential to gapfill max length ~700 spp.

Only 11 spp have no `length` but both `common_length` and `length_female`.

```{r}
length_fb <- length_fb_num %>%
  mutate(l_value = case_when(!is.na(length) ~ length,
                             !is.na(length_female) ~ round(length_female / l_f_coeff, 2),
                             !is.na(common_length) ~ round(common_length / l_c_coeff, 2),
                             TRUE ~ NA_real_)) %>%
  mutate(l_column = case_when(!is.na(length) ~ 'length',
                              !is.na(length_female) ~ 'length_female',
                              !is.na(common_length) ~ 'common_length',
                              TRUE ~ NA_character_)) %>%
  select(db, spec_code, species, length = l_value, l_column) %>%
  distinct()
```

## Cross validation

Leave-one-out cross validation to check efficacy of gapfilling (to species level) using imputation by genus, family, order, and class level mean.  If this is poor, may need to use MICE (per Boyce?)

```{r LOO crossvalidation function}

calc_xval <- function(name, df, r_at, r_up) {
  ### r_up <- 'genus'; r_at <- 'species'
  ### name <- spp_vec[1]
  ### df <- spp_df
  tmp_df <- df %>%
    rename(tmp_up := !!r_up,
           tmp_at := !!r_at)
  
  loocv_df <- tmp_df %>%
    group_by(tmp_up) %>%
    filter(n_distinct(tmp_at) > 1) %>%
    filter(name %in% tmp_at) %>%
    filter(tmp_at != name) %>%
    group_by(stressor) %>%
    summarize(vuln_xv = mean(vuln),
              sd_vuln_xv = sqrt(sum(sd_vuln^2, na.rm = TRUE)))
  
  left_out_df <- tmp_df %>%
    filter(tmp_at == name) %>%
    select(taxon, stressor, !!r_up := tmp_up, !!r_at := tmp_at, vuln, sd_vuln) %>%
    distinct()
  
  loocv_result <- left_out_df %>%
    left_join(loocv_df, by = 'stressor') %>%
    filter(!is.na(vuln_xv))

  return(loocv_result)
}

```

```{r run crossvalidation at from species level}

spp_vec <- unique(spp_df$species)

xval_s_g_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = spp_df, r_at = 'species', r_up = 'genus') %>%
  bind_rows()

xval_s_f_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = spp_df, r_at = 'species', r_up = 'family') %>%
  bind_rows()

xval_s_o_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = spp_df, r_at = 'species', r_up = 'order') %>%
  bind_rows()

xval_s_c_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = spp_df, r_at = 'species', r_up = 'class') %>%
  bind_rows()

```

```{r summarize crossval results}
summarize_xval <- function(xval_df, vars) {
  xval_summary <- xval_df %>%
    group_by(across(all_of(vars))) %>%
    mutate(vuln_diff = vuln - vuln_xv,
           sd_vuln_diff = sd_vuln - sd_vuln_xv) %>%
    summarize(rmse_vuln = sqrt(mean(vuln_diff^2)),
              rmse_sd_vuln = sqrt(sum(sd_vuln_diff^2, na.rm = TRUE) / n()),
              v_mean = mean(vuln),
              sd_v_mean = 1/n() * sqrt(sum(sd_vuln^2, na.rm = TRUE)),
              n_in_group = n(),
              .groups = 'drop')
}

xval_s_g_sum <- summarize_xval(xval_s_g_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
xval_s_f_sum <- summarize_xval(xval_s_f_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
xval_s_o_sum <- summarize_xval(xval_s_o_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
xval_s_c_sum <- summarize_xval(xval_s_c_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
```

``` {r compare and plot}
compare_rmse_df <- xval_s_g_sum %>%
  select(taxon, stressor, genus = rmse_vuln, n_g = n_in_group) %>%
  full_join(xval_s_f_sum %>% select(taxon, stressor, family = rmse_vuln, n_f = n_in_group), 
            by = c('taxon', 'stressor')) %>%
  full_join(xval_s_o_sum %>% select(taxon, stressor, order = rmse_vuln, n_o = n_in_group), 
            by = c('taxon', 'stressor')) %>%
  full_join(xval_s_c_sum %>% select(taxon, stressor, class = rmse_vuln, n_c = n_in_group), 
            by = c('taxon', 'stressor')) %>%
  mutate(across(where(is.numeric), ~round(.x, 4)))

DT::datatable(compare_rmse_df)

str_fixes <- read_csv(here('_raw_data/clean_taxa_and_strs.csv')) %>%
  rename(stressor = raw, str_lbl = clean)
tx_fixes <- read_csv(here('_raw_data/clean_taxa_and_strs.csv')) %>%
  rename(taxon = raw, tx_lbl = clean)

plot_df <- compare_rmse_df %>%
  gather(gf_level, rmse, -taxon, -stressor, -starts_with('n_')) %>%
  mutate(gf_level = factor(gf_level, levels = c('genus', 'family', 'order', 'class'))) %>%
  left_join(str_fixes, by = 'stressor') %>%
  left_join(tx_fixes, by = 'taxon')


p <- ggplot(plot_df, aes(x = as.integer(gf_level), y = rmse, group = tx_lbl, color = tx_lbl)) +
  geom_line() +
  facet_wrap(~str_lbl) +
  scale_x_continuous(breaks = 1:4, labels = c('genus', 'family', 'order', 'class')) +
  scale_color_brewer(palette = 'Dark2') +
  theme_minimal() +
  theme(text = element_text(size = 8),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5)) +
  labs(y = 'RMSE (vulnerability)',
       x = 'Imputation rank',
       color = 'Taxon')

ggsave(here('figs/up_down_gapfill_crossval.png'), height = 5, width = 6, dpi = 300)

knitr::include_graphics(here('figs/up_down_gapfill_crossval.png'))
```


## Gapfill FB/SLB length data

For purposes of identifying functional groups.  To combine length data, first preference is for continuous length measures from FB/SLB.  Where possible, we will upstream/downstream gap these values to unknown species in each represented family.  These will be compared to values from the spp vulnerability data for accuracy.  Any species not captured in this way can be gapfilled using length bins from the spp vulnerability data.  

### Use WoRMS API to resolve names

``` {r}

record_df <- collect_records(length_fb, field = 'length', file_tag = 'resolve_names_fb_length') %>%
  filter(aphia_id != -9999)

length_fb_fixed <- length_fb %>%
  left_join(record_df, by = c('species' = 'orig_sciname')) %>%
  mutate(species = ifelse(!is.na(valid_name), valid_name, species))
  

spp_from_worms <- assemble_worms()

length_worms_fb <- spp_from_worms %>%
  left_join(length_fb_fixed, by = 'species') %>%
  mutate(db = ifelse(is.na(db), 'worms', db))
### Here are the matched numbers by database and length source
table(length_worms_fb %>% select(db, l_column))

length_fb_gf <- gapfill_up_down(length_worms_fb, 'length')
                              
# table(length_fb_gf %>% select(class, gf_level))
# length_fb_gf %>% group_by(db) %>% summarize(n_tot = n(), n_val = sum(!is.na(log_l)))
```

<!-- ## Cross validation -->

<!-- Leave-one-out cross validation to check efficacy of gapfilling (to species level) using imputation by genus, family, order, and class level mean.  If this is poor, may need to use MICE (per Boyce?) -->

```{r LOO crossvalidation function, eval = FALSE}

calc_xval <- function(name, df, r_at, r_up, field) {
  ### r_up <- 'genus'; r_at <- 'species'
  ### name <- spp_vec[1]
  tmp_df <- df %>%
    rename(tmp_up := !!r_up,
           tmp_at := !!r_at,
           field  := !!field)
  
  loocv_df <- tmp_df %>%
    group_by(tmp_up) %>%
    filter(n_distinct(tmp_at) > 1) %>%
    filter(name %in% tmp_at) %>%          ### filter to up-rank containing this species
    filter(tmp_at != name) %>%            ### drop current species
    summarize(field_xv = mean(field)) %>% ### summarize for all other species in up-rank 
    rename(!!paste0(field, '_xv') := field_xv)
    
  
  left_out_df <- tmp_df %>%
    filter(tmp_at == name) %>%
    select(!!r_up := tmp_up, !!r_at := tmp_at, !!field := field) %>%
    distinct()
  
  loocv_result <- loocv_df %>%
    left_join(left_out_df, by = c('tmp_up' = r_up)) %>%
    filter(!is.na(!!paste0(field, '_xv')))

  return(loocv_result)
}

```

```{r run crossvalidation at from species level, eval = FALSE}

length_worms_fb_clean <- length_worms_fb %>%
  filter(!is.na(length))

spp_vec <- length_worms_fb_clean %>%
  .$species %>% unique()

xval_s_g_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = length_worms_fb_clean, 
                                  field = 'length',
                                  r_at = 'species', r_up = 'genus') %>%
  bind_rows()

xval_s_f_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = spp_df, r_at = 'species', r_up = 'family') %>%
  bind_rows()

xval_s_o_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = spp_df, r_at = 'species', r_up = 'order') %>%
  bind_rows()

xval_s_c_df <- parallel::mclapply(spp_vec, mc.cores = 20,
                                  FUN = calc_xval, 
                                  df = spp_df, r_at = 'species', r_up = 'class') %>%
  bind_rows()

```

```{r summarize crossval results, eval = FALSE}
summarize_xval <- function(xval_df, vars) {
  xval_summary <- xval_df %>%
    group_by(across(all_of(vars))) %>%
    mutate(vuln_diff = vuln - vuln_xv,
           sd_vuln_diff = sd_vuln - sd_vuln_xv) %>%
    summarize(rmse_vuln = sqrt(mean(vuln_diff^2)),
              rmse_sd_vuln = sqrt(sum(sd_vuln_diff^2, na.rm = TRUE) / n()),
              v_mean = mean(vuln),
              sd_v_mean = 1/n() * sqrt(sum(sd_vuln^2, na.rm = TRUE)),
              n_in_group = n(),
              .groups = 'drop')
}

xval_s_g_sum <- summarize_xval(xval_s_g_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
xval_s_f_sum <- summarize_xval(xval_s_f_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
xval_s_o_sum <- summarize_xval(xval_s_o_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
xval_s_c_sum <- summarize_xval(xval_s_c_df, c('taxon', 'stressor')) %>%
  mutate(rmse_over_mean = rmse_vuln / v_mean)
```

``` {r compare and plot, eval = FALSE}
compare_rmse_df <- xval_s_g_sum %>%
  select(taxon, stressor, genus = rmse_vuln, n_g = n_in_group) %>%
  full_join(xval_s_f_sum %>% select(taxon, stressor, family = rmse_vuln, n_f = n_in_group), 
            by = c('taxon', 'stressor')) %>%
  full_join(xval_s_o_sum %>% select(taxon, stressor, order = rmse_vuln, n_o = n_in_group), 
            by = c('taxon', 'stressor')) %>%
  full_join(xval_s_c_sum %>% select(taxon, stressor, class = rmse_vuln, n_c = n_in_group), 
            by = c('taxon', 'stressor')) %>%
  mutate(across(where(is.numeric), ~round(.x, 4)))

DT::datatable(compare_rmse_df)

str_fixes <- read_csv(here('_raw_data/clean_taxa_and_strs.csv')) %>%
  rename(stressor = raw, str_lbl = clean)
tx_fixes <- read_csv(here('_raw_data/clean_taxa_and_strs.csv')) %>%
  rename(taxon = raw, tx_lbl = clean)

plot_df <- compare_rmse_df %>%
  gather(gf_level, rmse, -taxon, -stressor, -starts_with('n_')) %>%
  mutate(gf_level = factor(gf_level, levels = c('genus', 'family', 'order', 'class'))) %>%
  left_join(str_fixes, by = 'stressor') %>%
  left_join(tx_fixes, by = 'taxon')


p <- ggplot(plot_df, aes(x = as.integer(gf_level), y = rmse, group = tx_lbl, color = tx_lbl)) +
  geom_line() +
  facet_wrap(~str_lbl) +
  scale_x_continuous(breaks = 1:4, labels = c('genus', 'family', 'order', 'class')) +
  scale_color_brewer(palette = 'Dark2') +
  theme_minimal() +
  theme(text = element_text(size = 8),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = .5)) +
  labs(y = 'RMSE (vulnerability)',
       x = 'Imputation rank',
       color = 'Taxon')

ggsave(here('figs/up_down_gapfill_crossval.png'), height = 5, width = 6, dpi = 300)

knitr::include_graphics(here('figs/up_down_gapfill_crossval.png'))
```



## Compare to bins in vulnerability traits data

Compare vulnerability trait data (bins: 1 = '0.5mm-49mm', 2 = '50mm-999mm', 3 = '>1000mm') to matched or gapfilled length.  Remember that FishBase/SeaLifeBase length is in centimeters.
```{r}
check_df <- length_vuln %>%
  inner_join(length_fb_gf, by = c('spp_gp' = 'species')) %>%
  rename(length = value) %>%
  filter(!is.na(bin) & !is.na(length)) %>%
  mutate(match = case_when(bin == 1 & length < 5 ~ 'small',
                           bin == 2 & between(length, 5, 100) ~ 'med',
                           bin == 3 & length >= 100 ~ 'large',
                           bin == 1 & length >= 5 ~ 'bin too low',
                           bin == 2 & length >= 100 ~ 'bin too low',
                           bin == 3 & length < 100 ~ 'bin too high',
                           bin == 2 & length < 5 ~ 'bin too high',
                           TRUE ~ 'wrong!')) 
table(check_df %>% select(db, match))
ggplot(check_df, aes(x = bin, y = length, color = match)) +
  geom_jitter(alpha = .5) +
  scale_color_viridis_d()

pct_correct_bins <- round(100 * sum(!str_detect(check_df$match, 'bin too')) / nrow(check_df))

```

The easily matched species are correctly binned `r pct_correct_bins`% of the time.  Spot checks generally seem to err in favor of the FishBase/SeaLifeBase length numbers.

While we've gapfilled to the class level, for file size and data utility, let's discard results for unmatched/filled species; also discard those filled at the class level, as that is stretching the numbers quite a bit farther than can probably be justified...

Counts of species with lengths in the FishBase/SeaLifeBase databases, by class, after gapfilling:

```{r}
gf_levels <- c('gf_match', 'gf_genus', 'gf_family', 'gf_order', 'gf_class')
length_gf_summary <- length_fb_gf %>%
  filter(gf_level <= 5 & !is.na(gf_level)) %>%
  group_by(db, kingdom, phylum, class, gf_level) %>%
  summarize(n = n(), .groups = 'drop') %>%
  mutate(gf_level = gf_levels[gf_level],
         gf_level = factor(gf_level, levels = gf_levels)) %>%
  spread(gf_level, n)

DT::datatable(length_gf_summary)
```

## Write out results

Discard results for unmatched/filled species; also discard those filled at the class level, as that is stretching the numbers quite a bit farther than can probably be justified...

```{r}
results_df <- length_fb_gf %>%
  select(species, trait, value, sd, nspp, gf_level) %>%
  filter(gf_level <= 4) %>%
  distinct()

write_csv(results_df, here('_data/traits_grouping/trait_length_cm.csv'))
```

