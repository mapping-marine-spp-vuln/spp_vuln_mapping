---
title: 'Collect reproductivity traits'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(oharac)
oharac::setup()
library(rfishbase)
source(here('common_fxns.R'))

### used for joining and gapfilling
spp_from_worms <- assemble_worms() ### from common_fxns.R

```

# Summary

Gather data on reproductive traits from FishBase and the species vulnerability project: Max fecundity, generation time, parental care (pre-birth/hatch), parental dependence (post-birth/hatch), PLD.  Gapfill using downfill where appropriate (no up/down; that will be done later via MICE)

# Data

This script will use processed valid species traits from the species vulnerability project, plus FishBase and SeaLifeBase.

FishBase is a scientific database, and this has the implication - among others - that its use and the use of its contents are free as long as due credit is given.

This may be done at different levels, for which we suggest different forms of citations:

* when referring to FishBase concepts and design, cite its architects (Froese and Pauly 2000);
* when referring to a set of values extracted from a FishBase table, cite the author(s) of the original data, e.g., "Houde and Zastrow (1993)", or "Welcomme (1988)". To help us track the use of FishBase in the literature, we would appreciate your also citing Froese and Pauly (2000) in an appropriate part of your text, as the source of the information;
* when discussing the features of a FishBase table, cite the section documenting that table, e.g., "Sa-a et al. (2000)."

## References

* Froese, R. and D. Pauly, Editors. 2000. FishBase 2000: concepts, design and data sources. ICLARM, Los Baños, Laguna, Philippines. 344 p.
* Houde, E.D. and C.E. Zastrow. 1993. Ecosystem- and taxon-specific dynamic energetics properties of fish larvae assemblages. Bull. Mar. Sci. 53(2):290-335.
* Sa-a, P., M.L. Palomares and D. Pauly. 2000. The FOOD ITEMS table, p. 182-188. In R. Froese and D. Pauly (eds.) FishBase 2000: concepts, design and data sources. ICLARM, Los Baños, Laguna, Philippines. 344 p.
* Welcomme, R.L. 1988. International introductions of inland aquatic species. FAO Fish. Tech. Pap. 294, 318 p.
* Butt, N. et al. 2021. 

# Methods

## Age at maturity: Read in data

Read in data from vulnerability project and fishbase/sealifebase.  First priority is to understand max age at maturity with data from species vulnerability trait data, which can achieve ~11000 spp.  FB/SLB have many NAs for these, but with a continuous value for age to maturity, we could potentially use upstream/downstream gapfilling (to the order level) to plug in values for additional species not included in the vulnerability dataset - however, we will rely on MICE to perform this gapfill later.

### Vulnerability traits

```{r age to maturity from vulnerability}
age_mat_vuln <- get_vuln_traits() %>%
  filter(trait == 'age_to_1st_reproduction_generation_time') %>%
  mutate(trait_value = factor(trait_value,
                              levels = c('<1yr', '1-5yrs', '5-10yrs', '10-20yrs', '>20yrs')),
         bin = as.integer(trait_value))

age_mat_vuln_gf <- downfill(age_mat_vuln) %>%
  select(species, trait, value = trait_value) %>%
  distinct() %>%
  mutate(source = 'vuln')
```

### Fishbase/Sealifebase

```{r age to maturity from fishbase}

age_mat_fb_f <- here('int/fb_age_mat_raw.csv')

if(!file.exists(age_mat_fb_f)) {
  fields <- c('age', 'tm')
  
  mat_fb_raw <- get_fb_slb(rfishbase::maturity,
                         keep_cols = fields, keep_fxn = contains,
                         drop_cols = '_ref', drop_fxn = ends_with) %>%
    select(db, spec_code, species, tm, age_mat_min, age_mat_min2) %>%
    filter(!is.na(tm) | !is.na(age_mat_min) | !is.na(age_mat_min2))
  
  mat_fb_num <- mat_fb_raw %>%
    mutate(spec_code = as.integer(spec_code),
           across(contains(fields), ~as.numeric(.x)))
  
  write_csv(mat_fb_num, age_mat_fb_f)
}

mat_fb_num <- read_csv(age_mat_fb_f)
  
lm_amm <- lm(age_mat_min ~ tm, data = mat_fb_num); coef_amm <- lm_amm$coefficients[2]
# summary(lm_amm)
### slope = .76, p << .001, adj.R^2 = .67
lm_amm2 <- lm(age_mat_min2 ~ tm, data = mat_fb_num); coef_amm2 <- lm_amm2$coefficients[2]
# summary(lm_amm2)
### slope = 1.43, p << .001, adj.R^2 = .80

mat_fb <- mat_fb_num %>%
  mutate(age_mat = case_when(!is.na(tm) ~ tm,
                             !is.na(age_mat_min2) ~ age_mat_min2 / coef_amm2,
                             TRUE ~ age_mat_min / coef_amm)) %>%
  select(db, spec_code, species, age_mat) %>%
  filter(!is.na(age_mat))
### note this keeps duplicate species, but for imputation those observations
### can be informative.

```

Use WoRMS API to resolve names

```{r resolve unmatched spp from fishbase}

record_df <- collect_records(mat_fb, field = 'age_mat', file_tag = 'resolve_names_fb_maturity') %>%
  filter(aphia_id != -9999)

mat_fb_clean <- mat_fb %>%
  left_join(record_df, by = c('species' = 'orig_sciname')) %>%
  mutate(species = ifelse(!is.na(valid_name), valid_name, species)) %>%
  mutate(species = str_extract(species, '^[a-z]+ [a-z]+'))
    ### this drops subspp and var. names

summary(mat_fb_clean$value)

mat_fb_binned <- mat_fb_clean %>%
  mutate(val_bin = case_when(age_mat <   1 ~ '<1yr',
                             age_mat <=  5 ~ '1-5yrs',
                             age_mat <= 10 ~ '5-10yrs',
                             age_mat <= 20 ~ '10-20yrs',
                             age_mat >  20 ~ '>20yrs',
                             TRUE ~ 'oops')) %>%
  select(species, val_num = age_mat, value = val_bin) %>%
  distinct() %>%
  mutate(source = 'fb')

age_mat_all <- bind_rows(age_mat_vuln_gf, mat_fb_binned) %>%
  mutate(trait = 'age_mat')

age_mat_all$value %>% table()
```

Without gapfilling, we get `r mat_fb$species %>% n_distinct()`  distinct species, at least some of which are freshwater.


## Fecundity

Read in data from vulnerability project and fishbase/sealifebase.  Examine potential for variables to be used to gapfill for max fecundity.  

```{r fecundity from vuln}
f_vals <- c('<1', '1-2' , '2-5', '5-10', '10-20', '20-50', '50-100', '100-1000', '1000-10000', '>10000')      

fecund_vuln <- get_vuln_traits() %>%
  filter(trait == 'fecundity') %>%
  mutate(trait_value = factor(trait_value,
                              levels = f_vals),
         bin = as.integer(trait_value))

fecund_vuln_gf <- downfill(fecund_vuln) %>%
  select(species, trait, value = trait_value) %>%
  distinct() %>%
  mutate(source = 'vuln')
```


```{r fecundity from fb and slb}
fecund_fb_f <- here('int/fb_fecund_raw.csv')

if(!file.exists(fecund_fb_f)) {
  fields <- c('fecun')
  fecund_fb_raw <- get_fb_slb(fxn = fecundity,
                       keep_cols = fields, keep_fxn = contains,
                       drop_cols = '_ref', drop_fxn = ends_with) %>%
    select(db, spec_code, species, starts_with('fecun'))
  # summary(fecund_df_raw)
  # fecund_df_raw %>% summarize(across(starts_with('fecun'), .fns = ~sum(!is.na(.x))))
  
  fecund_fb_num <- fecund_fb_raw %>%
    mutate(spec_code = as.integer(spec_code),
           across(contains(c('max', 'min', 'mean')), ~as.numeric(.x)))
  
  write_csv(fecund_fb_num, fecund_fb_f)
}

fecund_fb_num <- read_csv(fecund_fb_f)

lm_fec1 <- lm(fecundity_max ~ fecundity_min, data = fecund_fb_num); coef_fec1 <- lm_fec1$coefficients[2]
# summary(lm_fec1)
### slope = 2.92, p << .001, adj.R^2 = .83
lm_fec2 <- lm(fecundity_max ~ fecundity_mean, data = fecund_fb_num); coef_fec2 <- lm_fec2$coefficients[2]
# summary(lm_fec2)
### slope = 1.15, p << .001, adj.R^2 = .95

fecund_fb <- fecund_fb_num %>%
  mutate(max_fecundity = case_when(!is.na(fecundity_max) ~ fecundity_max,
                             !is.na(fecundity_mean) ~ fecundity_mean * coef_fec2,
                             !is.na(fecundity_min) ~ fecundity_min * coef_fec1,
                             TRUE ~ NA_real_)) %>%
  select(db, spec_code, species, max_fecundity) %>%
  filter(!is.na(max_fecundity))
### keep all observations for each species, to better inform imputation
```


``` {r resolve and finalize fecundity}
record_df <- collect_records(fecund_fb, field = 'max_fecundity', file_tag = 'resolve_names_fb_fecundity') %>%
  filter(aphia_id != -9999)

fecund_fb_clean <- fecund_fb %>%
  left_join(record_df, by = c('species' = 'orig_sciname')) %>%
  mutate(species = ifelse(!is.na(valid_name), valid_name, species)) %>%
  mutate(species = str_extract(species, '^[a-z]+ [a-z]+'))
    ### this drops subspp and var. names

summary(fecund_fb_clean$max_fecundity)

fecund_fb_binned <- fecund_fb_clean %>%
  mutate(val_bin = case_when(max_fecundity <   1 ~ '<1',
                             max_fecundity <=  2 ~ '1-2',
                             max_fecundity <=  5 ~ '2-5',
                             max_fecundity <= 10 ~ '5-10',
                             max_fecundity <= 20 ~ '10-20',
                             max_fecundity <= 50 ~ '20-50',
                             max_fecundity <= 100 ~ '50-100',
                             max_fecundity <= 1000 ~ '100-1000',
                             max_fecundity <= 10000 ~ '1000-10000',
                             max_fecundity >  10000 ~ '>10000',
                             TRUE ~ 'oops')) %>%
  select(species, val_num = max_fecundity, value = val_bin) %>%
  distinct() %>%
  mutate(source = 'fb')

fecund_all <- bind_rows(fecund_vuln_gf, fecund_fb_binned) %>%
  mutate(trait = 'fec') %>%
  mutate(value = factor(value, levels = f_vals))

fecund_all$value %>% table()
```


## Parental investment [SKIP]

Read in data from vulnerability project and fishbase/sealifebase.  Here we have data on parental investment (maternal/paternal/both/neither) and protection mode (bearers/guarders/non-guarders).  Assign protection mode from bearers (high) to non-guarders (low).  Because the parental investment score here only covers FishBase, and is not comparable to that in the vulnerability traits data (which is closer to the protection trait), let's skip it in favor of the post-birth dependence trait in the vulnerability traits data.

```{r parental investment from fishbase, eval = FALSE}
fields <- c('parental', 'guild')

reprod_fb_raw <- get_fb_slb(fxn = reproduction,
                     keep_cols = fields, keep_fxn = contains,
                     drop_cols = '_ref', drop_fxn = ends_with)

protect_fb <- reprod_fb_raw %>%
  mutate(rep_guild1 = factor(rep_guild1, levels = c('nonguarders', 'guarders', 'bearers')),
         protect_score = as.integer(rep_guild1)) %>%
  filter(!is.na(protect_score) & !is.na(species)) %>%
  select(db, spec_code, species, protect_score) %>%
  group_by(db, spec_code, species) %>%
  summarize(protect_score = mean(protect_score), .groups = 'drop')

record_df <- collect_records(protect_fb, field = 'protect_score', file_tag = 'resolve_names_fb_protect') %>%
  filter(aphia_id != -9999)

protect_df <- protect_fb %>%
  left_join(record_df, by = c('species' = 'orig_sciname')) %>%
  mutate(species = ifelse(!is.na(valid_name), valid_name, species)) %>%
  mutate(species = str_extract(species, '^[a-z]+ [a-z]+')) %>%
    ### this drops subspp and var. names
  right_join(spp_from_worms, by = 'species')

protect_df %>% 
  filter(!is.na(protect_score)) %>% 
  select(db, protect_score) %>% table()

```

For parental investment: We get 5042 distinct species, all of which are from FishBase, guessing some of which are freshwater.  For protection mode, we get 21890 species across both FB and SLB.

For the vulnerability data, parental investment is based on: (egg-layer unattended, egg-layer, live birth/egg care, spawner) - which seems comparable to protection mode above.  Post-birth/hatching parental dependence is a time scale: less than a week up to more than a year.

```{r parental involvement from vuln, eval = FALSE}
parent_vuln <- get_vuln_traits() %>%
  filter(str_detect(trait, 'parental_investment')) %>%
  mutate(parent_score = case_when(str_detect(trait_value, 'spawn|unattend') ~ 0,
                                trait_value == 'egg-layer' ~ 1,
                                trait_value == 'live birth/egg care' ~ 2))

parent_vuln_gf <- downfill(parent_vuln) %>%
  select(species, trait, value = trait_value) %>%
  mutate(trait = 'par_inv') %>%
  distinct()

depend_vuln <- get_vuln_traits() %>%
  filter(trait == 'post_birth_hatching_parental_dependence') %>%
  mutate(trait_value = factor(trait_value, levels = c('na', '<week', 'week-month', 'month-year', '>year')),
         depend_score = as.double(trait_value) - 1)
           ### so "na" is 0 dependence, i.e., no post-birth care

depend_vuln_gf <- downfill(depend_vuln) %>%
  select(species, trait, value = trait_value) %>%
  mutate(trait = 'par_dep') %>%
  distinct()
```


## Planktonic larval duration [SKIP]

From the vulnerability traits, we can identify PLD as a potential variable for discerning functional groups.

```{r pld from vuln, eval = FALSE}
pld_vals <- c('not larvae', '<1day', '<1week', '<1month', '<4months', '4months-1yr', '>1yr')

pld_vuln <- get_vuln_traits() %>%
  filter(str_detect(trait, 'planktonic_larval_duration')) %>%
  mutate(trait_value = factor(trait_value, levels = pld_vals))

pld_vuln_downfill <- downfill(pld_vuln)

pld_vuln_gf <- pld_vuln_downfill %>%
  select(species, trait, value = trait_value) %>%
  mutate(trait = 'pld') %>%
  distinct()

```

### Combine data into a single dataframe and save

Write out the results.  In this case, no gapfilling (all down-filling).  Some species might have multiple values of a trait so this must be addressed eventually.

```{r combine and write out}

repr_out_df <- bind_rows(# depend_vuln_gf,
                         # parent_vuln_gf,
                         # pld_vuln_gf,
                         age_mat_all,
                         fecund_all)

write_csv(repr_out_df, here('_data/traits_grouping/trait_reproduction.csv'))

# repr_pc1_df <- repr_out_df %>%
#   mutate(trait = 'repr_pc1') %>%
#   select(species, gf_level, trait, value = repr_pc1)
# write_csv(repr_pc1_df, here('_data/traits_grouping/trait_repr_pc1.csv'))
# repr_pc2_df <- repr_out_df %>%
#   mutate(trait = 'repr_pc2') %>%
#   select(species, gf_level, trait, value = repr_pc2)
# write_csv(repr_pc2_df, here('_data/traits_grouping/trait_repr_pc2.csv'))

```

