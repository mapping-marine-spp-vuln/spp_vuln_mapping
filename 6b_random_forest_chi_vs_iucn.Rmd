---
title: "Compare cumulative impacts per species to IUCN status"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(raster)
library(tidyverse)
library(here)
library(RColorBrewer)
library(oharac)
source(here('common_fxns.R'))

library(caret)
library(randomForest)

```

# Summary

Compare the relative CHI across species ranges (by stressor and for full range vs. coastal-only range) to spp IUCN Red List threatened status.  The relative impact is effectively the average impact per km^2^ across the species' range.

Perform a regression of IUCN extinction risk classification as a function of relative overall CHI and overall range, and then do the same for coastal.

# Data

* Species impact scores from script 5
* IUCN extinction risk scores from IUCN

# Methods

## Read in species impacts for those spp assessed by IUCN; summarize to CHI

Summarize to cumulative impacts by entire range and by coastal range.

Each file has a row for each stressor-vulnerability match; columns are:

* `str_vuln` (chr): name of stressor/vuln combo, as <str>-<vuln>
* `impact_tot` (dbl): sum across all cells of stressor intensity $\times$ vulnerability $\times$ ocean area
* `impact_coastal` (dbl): sum across all coastal cells (â‰¤200m) of stressor intensity $\times$ vulnerability $\times$ ocean area
* `range_tot_km2` (dbl): sum of ocean area of all cells across entire range
* `range_coastal_km2` (dbl): sum of ocean area of all cells across coastal range


```{r}
spp_chi_file <- here_anx('int/spp_chi_summary.csv')

if(!file.exists(spp_chi_file)) {
  spp_imp_fs <- list.files(here_anx('impacts_by_species'), 
                           pattern = '^impacts_.+.csv', full.names = TRUE)
  
  spp_imp_df <- parallel::mclapply(spp_imp_fs, mc.cores = 40,
                                   read_csv, show_col_types = FALSE) %>%
    setNames(basename(spp_imp_fs)) %>%
    bind_rows(.id = 'f')
  
  spp_ranges <- spp_imp_df %>%
    select(f, range_km2, range) %>%
    distinct() %>%
    spread(range, range_km2) %>%
    rename(range_cst_km2 = coastal, range_tot_km2 = full)
  
  iucn_worms_lookup <- read_csv(here('_data/iucn_spp', 'iucn_to_worms_match.csv'))

  spp_impacts_df <- spp_imp_df %>%
    select(-range_km2) %>%
    spread(range, impact_tot) %>%
    rename(impact_tot = full, impact_cst = coastal) %>%
    left_join(spp_ranges, by = 'f') %>%
    ### extract species and map info from filename
    mutate(map_src = str_extract(f, '_iucn_|_am_') %>% str_remove_all('_'),
           iucn_sid = str_extract(f, '[0-9]+') %>% as.integer(),
           spp_from_f = str_remove_all(f, 'impacts_(am|iucn)_|.csv')) %>%
    left_join(iucn_worms_lookup, by = 'iucn_sid') %>%
    mutate(sciname = ifelse(is.na(worms_name), 
                            str_replace_all(spp_from_f, '_', ' '),
                            worms_name)) %>%
    select('sciname', 'iucn_sid', 'map_src', 'vuln', 'stressor', 
           'impact_cst', 'impact_tot', 'range_cst_km2', 'range_tot_km2') %>%
    distinct() %>%
    filter(range_tot_km2 > 0 & !is.na(impact_tot))
    
  write_csv(spp_impacts_df, spp_chi_file)
}
```

### Assemble IUCN Red List categories for species in IUCN maps and AquaMaps maps

``` {r}

worms_taxa <- assemble_worms() %>%
  select(sciname = species, phylum, class) %>%
  distinct()

iucn_worms_lookup <- read_csv(here('_data/iucn_spp', 'iucn_to_worms_match.csv'))

iucn_assessed <- read_csv(here('_data/iucn_spp/iucn_marine_spp_info_2021-3.csv')) %>%
  select(iucn_sid, cat, cat_score) %>%
  left_join(iucn_worms_lookup, by = 'iucn_sid') %>%
  mutate(threatened = cat %in% c('vu', 'en', 'cr', 'ex'),
         atrisk     = cat %in% c('nt', 'vu', 'en', 'cr', 'ex')) %>%
  select(iucn_sid, iucn_sciname = sciname, sciname = worms_name, cat, cat_score, threatened, atrisk)
iucn_mapped <- read_csv(here('_data/iucn_spp/spp_marine_maps_2021-3.csv'))

assessed_in_am <- get_am_spp_info() %>%
  select(am_sid, am_sciname, sciname, iucn_sid) %>%
  inner_join(iucn_assessed %>% 
               select(iucn_sid, cat, threatened, atrisk) %>% distinct(), 
             by = 'iucn_sid') %>%
  select(sciname, cat, threatened, atrisk) %>%
  distinct() %>%
  mutate(map_src = 'am',
         iucn_sid = -1)

assessed_in_iucn_maps <- iucn_assessed %>%
  filter(iucn_sid %in% iucn_mapped$iucn_sid) %>%
  select(sciname, iucn_sid, cat, threatened, atrisk) %>%
  distinct() %>%
  mutate(map_src = 'iucn')

assessed_df <- bind_rows(assessed_in_am, assessed_in_iucn_maps) %>%
  group_by(sciname) %>%
  filter(n() == 1 | map_src == 'iucn') %>%
  left_join(worms_taxa, by = 'sciname') %>%
  filter(cat != 'dd') %>%
  filter(!is.na(class))

```

### Combine IUCN categories with impacts

``` {r}
iucn_impacts_df <- read_csv(spp_chi_file) %>%
  mutate(iucn_sid = ifelse(is.na(iucn_sid), -1, iucn_sid)) %>%
  inner_join(assessed_df, by = c('sciname', 'iucn_sid', 'map_src')) %>%
  mutate(iucn_fct = toupper(cat),
         iucn_fct = factor(iucn_fct, levels = c('LC', 'NT', 'VU', 'EN', 'CR', 'EX')))

check_df <- iucn_impacts_df %>%
  select(sciname, iucn_sid, map_src) %>%
  distinct() %>%
  group_by(sciname) %>%
  summarize(n = n(),
            map_src = paste(unique(map_src), collapse = ';'))
  
```

## Set up dataframe for coastal impacts and full range impacts

Calculate coastal impacts by vulnerability category - for categories like bycatch and habitat loss that map to multiple stressor layers, sum the impacts for all sources prior to calculating relative impact.

Alternately, what if we go stressor layer by stressor layer?

```{r vectors and counts per taxon}
phl_vec <- c('arthropoda', 'chordata', 'cnidaria', 'echinodermata', 'mollusca')
cls_vec <- c('actinopterygii', 'anthozoa', 'aves', 'bivalvia', 
             'cephalopoda', 'echinoidea', 'elasmobranchii', 'gastropoda', 
             'holothuroidea', 'malacostraca', 'mammalia', 'myxini', 'reptilia')

taxon_gps <- iucn_impacts_df %>%
  select(phylum, class) %>%
  distinct() %>%
  mutate(tx = case_when(phylum == 'chordata' ~ class,
                        class %in% c('cephalopoda', 'malacostraca') ~ class,
                        TRUE ~ phylum))
```

```{r}
cst_impacts_df <- iucn_impacts_df %>%
  group_by(sciname, stressor, range_cst_km2, threatened, phylum, class) %>%
  summarize(imp_sum = sum(impact_cst), .groups = 'drop') %>%
  filter(range_cst_km2 > 0) %>%
  mutate(rel_impact = imp_sum / range_cst_km2,
         inv_ln_range = 1/log(range_cst_km2),
         threatened = factor(threatened)) %>%
  select(-range_cst_km2, -imp_sum) %>%
  pivot_wider(names_from = stressor, values_from = rel_impact, values_fill = 0) %>%
  left_join(taxon_gps, by = c('phylum', 'class')) %>%
  distinct()
```

Subset coastal species impacts by taxonomic group.  Rather than set aside a test for post-RF, run a repeated k-fold cross validation on each entire taxon.  Use a typical default of 10 folds, and 10 repeats, per https://machinelearningmastery.com/repeated-k-fold-cross-validation-with-python.

``` {r}
cst_impacts_df %>% select(tx, threatened) %>% table()
```

``` {r}
spp_cst_imp_df <- cst_impacts_df %>%
  filter(tx == 'aves') %>%
  select(-sciname, -phylum, -class, -tx)


set.seed(51)

# smp <- caTools::sample.split(spp_cst_imp_df$threatened, SplitRatio = .8)
# spp_train <- subset(spp_cst_imp_df, smp == TRUE)
# spp_test  <- subset(spp_cst_imp_df, smp == FALSE)
spp_train <- spp_cst_imp_df

f1 <- threatened ~ .

tr_ctrl <- trainControl(method = 'repeatedcv', number = 10, repeats = 10)
### set up a tunegrid to include all cols, and step by 3
tunegrid <- data.frame(.mtry = seq(ncol(spp_train) - 1, 2, -4) %>% sort())

system.time({
  chi_thr_mdl <- train(form = f1,
                       data = spp_train,
                       method = 'rf',
                       tuneGrid = tunegrid,
                       trControl = tr_ctrl)
}) 
### for 96 spp, 5 folds, 10 repeats, about 6 seconds; 
### * 13 s for 10 folds; 25 for 20 folds - linear in folds
### * 11 s for 20 repeats; 22 sec for 40 reps - linear in repeats
print(chi_thr_mdl)
# Random Forest 
# 
# 96 samples
# 14 predictors
#  2 classes: 'FALSE', 'TRUE' 
# 
# No pre-processing
# Resampling: Cross-Validated (5 fold, repeated 10 times) 
# Summary of sample sizes: 78, 76, 77, 76, 77, 77, ... 
# Resampling results across tuning parameters:
# 
#   mtry  Accuracy   Kappa    
#    2    0.6803275  0.2770932
#    8    0.6899825  0.3193594
#   14    0.6993041  0.3446987
# 
# Accuracy was used to select the optimal model using the largest value.
# The final value used for the model was mtry = 14.

# chi_thr_pred <- predict(chi_thr_mdl, newdata = spp_test[-1])
# 
# conf_mtx <- spp_test %>%
#   mutate(pred = chi_thr_pred)
# 
# accuracy_test <- conf_mtx %>%
#   summarize(accuracy = sum(pred == threatened) / n()) %>%
#   pull(accuracy)
# exp_acc_test <- conf_mtx %>%
#   summarize(true_ground  = sum(threatened == TRUE),
#             true_pred    = sum(pred == TRUE),
#             false_ground = sum(threatened == FALSE),
#             false_pred   = sum(pred == FALSE),
#             exp_acc = (true_ground * true_pred + false_ground * false_pred) / n()^2) %>%
#   pull(exp_acc)
# kappa_test <- (accuracy_test - exp_acc_test) / (1 - exp_acc_test)
#   
# table(conf_mtx %>% select(threatened, pred))

```

### Tuning mtry

``` {r}
x <- spp_train[, -1]
y <- spp_train[, 1]
# Create model with default paramters
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 3)
seed <- 7
metric <- 'Accuracy'
set.seed(seed)
mtry <- sqrt(ncol(x)) %>% floor()
tunegrid <- expand.grid(.mtry = mtry)
rf_default <- train(f1, data = spp_train, method = 'rf', 
                    metric = metric, tuneGrid = tunegrid, trControl = control)
print(rf_default)
# Random Forest 
# 
# 96 samples
# 14 predictors
#  2 classes: 'FALSE', 'TRUE' 
# 
# No pre-processing
# Resampling: Cross-Validated (10 fold, repeated 3 times) 
# Summary of sample sizes: 86, 86, 86, 87, 86, 86, ... 
# Resampling results:
# 
#   Accuracy   Kappa    
#   0.6825926  0.2963921
# 
# Tuning parameter 'mtry' was held constant at a value of 3
```

``` {r}
# Random Search
control <- trainControl(method = 'repeatedcv', number = 7, repeats = 3, search = 'random')
set.seed(seed)
mtry <- sqrt(ncol(x))
rf_random <- train(f1, data = spp_train, method='rf', 
                   metric = metric, tuneLength = 8, trControl = control)
print(rf_random)
plot(rf_random)
```

``` {r}
# Grid search
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 3, search = 'grid')
set.seed(seed)
tunegrid <- expand.grid(.mtry = c(1:17))
rf_gridsearch <- train(f1, data = spp_train, method = 'rf', 
                       metric = metric, tuneGrid = tunegrid, trControl = control)
print(rf_gridsearch)
plot(rf_gridsearch)
```
