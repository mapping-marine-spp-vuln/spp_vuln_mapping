---
title: "Compare cumulative impacts per species to IUCN status"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(raster)
library(tidyverse)
library(here)
library(RColorBrewer)
library(oharac)
source(here('common_fxns.R'))

library(caret)
library(randomForest)

```

# Summary

Compare the relative CHI across species ranges (by stressor and for full range vs. coastal-only range) to spp IUCN Red List threatened status.  The relative impact is effectively the average impact per km^2^ across the species' range.

Perform a regression of IUCN extinction risk classification as a function of relative overall CHI and overall range, and then do the same for coastal.

Some refs used for learning random forest etc:

* parameter tuning (mtry parameter): https://machinelearningmastery.com/tune-machine-learning-algorithms-in-r/
* understanding kappa: https://stats.stackexchange.com/questions/82162/cohens-kappa-in-plain-english


# Data

* Species impact scores from script 5
* IUCN extinction risk scores from IUCN

# Methods

## Read in species impacts for those spp assessed by IUCN; summarize to CHI

Summarize to cumulative impacts by entire range and by coastal range.

Each file has a row for each stressor-vulnerability match; columns are:

* `str_vuln` (chr): name of stressor/vuln combo, as <str>-<vuln>
* `impact_tot` (dbl): sum across all cells of stressor intensity $\times$ vulnerability $\times$ ocean area
* `impact_coastal` (dbl): sum across all coastal cells (â‰¤200m) of stressor intensity $\times$ vulnerability $\times$ ocean area
* `range_tot_km2` (dbl): sum of ocean area of all cells across entire range
* `range_coastal_km2` (dbl): sum of ocean area of all cells across coastal range


```{r}
spp_chi_file <- here_anx('int/spp_chi_summary.csv')

if(!file.exists(spp_chi_file)) {
  spp_imp_fs <- list.files(here_anx('impacts_by_species'), 
                           pattern = '^impacts_.+.csv', full.names = TRUE)
  
  spp_imp_df <- parallel::mclapply(spp_imp_fs, mc.cores = 40,
                                   read_csv, show_col_types = FALSE) %>%
    setNames(basename(spp_imp_fs)) %>%
    bind_rows(.id = 'f')
  
  spp_ranges <- spp_imp_df %>%
    select(f, range_km2, range) %>%
    distinct() %>%
    spread(range, range_km2) %>%
    rename(range_cst_km2 = coastal, range_tot_km2 = full)
  
  iucn_worms_lookup <- read_csv(here('_data/iucn_spp', 'iucn_to_worms_match.csv'))

  spp_impacts_df <- spp_imp_df %>%
    select(-range_km2) %>%
    spread(range, impact_tot) %>%
    rename(impact_tot = full, impact_cst = coastal) %>%
    left_join(spp_ranges, by = 'f') %>%
    ### extract species and map info from filename
    mutate(map_src = str_extract(f, '_iucn_|_am_') %>% str_remove_all('_'),
           iucn_sid = str_extract(f, '[0-9]+') %>% as.integer(),
           spp_from_f = str_remove_all(f, 'impacts_(am|iucn)_|.csv')) %>%
    left_join(iucn_worms_lookup, by = 'iucn_sid') %>%
    mutate(sciname = ifelse(is.na(worms_name), 
                            str_replace_all(spp_from_f, '_', ' '),
                            worms_name)) %>%
    select('sciname', 'iucn_sid', 'map_src', 'vuln', 'stressor', 
           'impact_cst', 'impact_tot', 'range_cst_km2', 'range_tot_km2') %>%
    distinct() %>%
    filter(range_tot_km2 > 0 & !is.na(impact_tot))
    
  write_csv(spp_impacts_df, spp_chi_file)
}
```

### Assemble IUCN Red List categories for species in IUCN maps and AquaMaps maps

``` {r}

worms_taxa <- assemble_worms() %>%
  select(sciname = species, phylum, class) %>%
  distinct()

iucn_worms_lookup <- read_csv(here('_data/iucn_spp', 'iucn_to_worms_match.csv'))

iucn_assessed <- read_csv(here('_data/iucn_spp/iucn_marine_spp_info_2021-3.csv')) %>%
  select(iucn_sid, cat, cat_score) %>%
  left_join(iucn_worms_lookup, by = 'iucn_sid') %>%
  mutate(threatened = cat %in% c('vu', 'en', 'cr', 'ex'),
         atrisk     = cat %in% c('nt', 'vu', 'en', 'cr', 'ex')) %>%
  select(iucn_sid, iucn_sciname = sciname, sciname = worms_name, cat, cat_score, threatened, atrisk)
iucn_mapped <- read_csv(here('_data/iucn_spp/spp_marine_maps_2021-3.csv'))

assessed_in_am <- get_am_spp_info() %>%
  select(am_sid, am_sciname, sciname, iucn_sid) %>%
  inner_join(iucn_assessed %>% 
               select(iucn_sid, cat, threatened, atrisk) %>% distinct(), 
             by = 'iucn_sid') %>%
  select(sciname, cat, threatened, atrisk) %>%
  distinct() %>%
  mutate(map_src = 'am',
         iucn_sid = -1)

assessed_in_iucn_maps <- iucn_assessed %>%
  filter(iucn_sid %in% iucn_mapped$iucn_sid) %>%
  select(sciname, iucn_sid, cat, threatened, atrisk) %>%
  distinct() %>%
  mutate(map_src = 'iucn')

assessed_df <- bind_rows(assessed_in_am, assessed_in_iucn_maps) %>%
  group_by(sciname) %>%
  filter(n() == 1 | map_src == 'iucn') %>%
  left_join(worms_taxa, by = 'sciname') %>%
  filter(cat != 'dd') %>%
  filter(!is.na(class))

```

### Combine IUCN categories with impacts

``` {r}
iucn_impacts_df <- read_csv(spp_chi_file) %>%
  mutate(iucn_sid = ifelse(is.na(iucn_sid), -1, iucn_sid)) %>%
  inner_join(assessed_df, by = c('sciname', 'iucn_sid', 'map_src')) %>%
  mutate(iucn_fct = toupper(cat),
         iucn_fct = factor(iucn_fct, levels = c('LC', 'NT', 'VU', 'EN', 'CR', 'EX'))) %>%
  select(-iucn_sid, -map_src) %>%
  arrange(stressor, vuln)
```

## Set up dataframe for coastal impacts and full range impacts

Calculate coastal impacts by vulnerability category - for categories like bycatch and habitat loss that map to multiple stressor layers, sum the impacts for all sources prior to calculating relative impact.

Alternately, what if we go stressor layer by stressor layer?

```{r vectors and counts per taxon}
phl_vec <- c('arthropoda', 'chordata', 'cnidaria', 'echinodermata', 'mollusca')
cls_vec <- c('actinopterygii', 'anthozoa', 'aves', 'bivalvia', 
             'cephalopoda', 'echinoidea', 'elasmobranchii', 'gastropoda', 
             'holothuroidea', 'malacostraca', 'mammalia', 'myxini', 'reptilia')

taxon_gps <- iucn_impacts_df %>%
  select(phylum, class) %>%
  distinct() %>%
  mutate(tx = case_when(phylum == 'chordata' ~ class,
                        class %in% c('cephalopoda', 'malacostraca') ~ class,
                        TRUE ~ phylum))
```

```{r}
cst_impacts_df <- iucn_impacts_df %>%
  group_by(sciname, stressor, range_cst_km2, threatened, phylum, class) %>%
  summarize(imp_sum = sum(impact_cst), .groups = 'drop') %>%
  filter(range_cst_km2 > 0) %>%
  mutate(rel_impact = imp_sum / range_cst_km2,
         inv_ln_range = 1/log(range_cst_km2),
         threatened = factor(threatened)) %>%
  select(-range_cst_km2, -imp_sum) %>%
  pivot_wider(names_from = stressor, values_from = rel_impact, values_fill = 0) %>%
  left_join(taxon_gps, by = c('phylum', 'class')) %>%
  distinct()
```

Subset coastal species impacts by taxonomic group.  Rather than set aside a test for post-RF, run a repeated k-fold cross validation on each entire taxon.  Use a typical default of 10 folds, and 10 repeats, per https://machinelearningmastery.com/repeated-k-fold-cross-validation-with-python.

``` {r}
cst_impacts_df %>% select(tx, threatened) %>% table()
```

``` {r}
spp_cst_imp_df <- cst_impacts_df %>%
  filter(tx == 'mammalia') %>%
  select(-sciname, -phylum, -class, -tx)

calc_rand_forest <- function(df) {

  # set.seed(51)
  
  # smp <- caTools::sample.split(spp_cst_imp_df$threatened, SplitRatio = .8)
  # spp_train <- subset(spp_cst_imp_df, smp == TRUE)
  # spp_test  <- subset(spp_cst_imp_df, smp == FALSE)
  spp_train <- spp_cst_imp_df
  n_preds <- ncol(spp_train) - 1
  
  ### regress threatened status against all predictors
  f1 <- threatened ~ .
  
  ### set up train control for 10x-repeated 10-fold cross-validation
  tr_ctrl <- trainControl(method = 'repeatedcv', number = 10, repeats = 10)
  ### set up a tunegrid to step by three, up to all included predictors
  tunegrid <- data.frame(.mtry = c(seq(2, n_preds, 3), n_preds) %>% unique())
  
  system.time({
    chi_thr_mdl <- train(form = f1,
                         data = spp_train,
                         method = 'rf',
                         tuneGrid = tunegrid,
                         trControl = tr_ctrl)
  }) 
  
  print(chi_thr_mdl)
  
  pred_importance <- varImp(chi_thr_mdl)
  plot(pred_importance)
}
```

```{r}
library(Boruta)
set.seed(111)
boruta_spp_train <- Boruta(f1, data = spp_train, doTrace = 2)
print(boruta_spp_train)

# Boruta performed 99 iterations in 3.417672 secs.
#  9 attributes confirmed important: benth_str_2020, bycatch_pelagic_2017, cumulative,
# direct_human_2020, fishing_benthic_dest_2017 and 4 more;
#  6 attributes confirmed unimportant: biomass_removal, bycatch_benthic_2017, light_2018, oa_2020,
# sst_extremes_2020 and 1 more;
#  2 tentative attributes left: nutrient_2020, shipping_large_2021;

boruta_spp <- TentativeRoughFix(boruta_spp_train)
print(boruta_spp)

getSelectedAttributes(boruta_spp, withTentative = F)

##  [1] "age"      "default"  "housing"  "loan"     "contact"  "day"     
##  [7] "month"    "duration" "campaign" "pdays"    "previous" "poutcome"

bank_df <- attStats(boruta_spp)
print(bank_df)
```

``` {r}
boruta_cst_imp_df <- spp_cst_imp_df %>%
  select(threatened, all_of(getSelectedAttributes(boruta_spp, withTentative = F)))

set.seed(51)

# smp <- caTools::sample.split(spp_cst_imp_df$threatened, SplitRatio = .8)
# spp_train <- subset(spp_cst_imp_df, smp == TRUE)
# spp_test  <- subset(spp_cst_imp_df, smp == FALSE)
boruta_train <- boruta_cst_imp_df
n_preds <- ncol(boruta_train) - 1

### regress threatened status against all predictors
f1 <- threatened ~ .

### set up train control for 10x-repeated 10-fold cross-validation
tr_ctrl <- trainControl(method = 'repeatedcv', number = 10, repeats = 10)
### set up a tunegrid to step by three, up to all included predictors
tunegrid <- data.frame(.mtry = c(seq(2, n_preds, 3), n_preds) %>% unique())

system.time({
  boruta_chi_thr_mdl <- train(form = f1,
                       data = boruta_train,
                       method = 'rf',
                       tuneGrid = tunegrid,
                       trControl = tr_ctrl)
}) 

print(boruta_chi_thr_mdl)

pred_importance <- varImp(boruta_chi_thr_mdl)
plot(pred_importance)
```

### direction of effect

based on https://stackoverflow.com/questions/64388396/random-forest-variable-importance-and-direction-of-correlation-for-binomial-resp

```{r}
nx <- names(boruta_train)
nx <- nx[-which(nx == "threatened")]
res <- NULL
for(i in 1:length(nx)){
  p1 <- predict(boruta_chi_thr_mdl, newdata=boruta_train, type="prob")
  df2 <- boruta_train
  df2[[nx[i]]] <- df2[[nx[i]]] + sd(df2[[nx[i]]])
  p2 <- predict(boruta_chi_thr_mdl, newdata=df2, type="prob")
  diff <- (p2-p1)[,2]
  res <- rbind(res, c(mean(diff), sd(diff)))
}
colnames(res) <- c("effect", "sd")
rownames(res) <- nx
res
```

