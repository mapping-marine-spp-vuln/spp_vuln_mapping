---
title: "Random forest clustering demo"
author: "Casey O'Hara"
date: "6/23/2021"
output: html_document
---

borrowed from `https://nishanthu.github.io/articles/ClusteringUsingRandomForest.html` and updated to use `palmerpenguins`

# Introduction

Clustering belongs to unsupervised learning along with other branches like dimensionality reduction. The training samples do not have labels. The input data is then grouped into different classes, assigning each training sample to one group based on some similarity measure (usually Euclidean distance). The classic method of clustering uses an algorithm called kmeans

For the purposes of plotting in 2D, the first 2 principal components are used are axes.

```{r setup}
library(tidyverse)
library(palmerpenguins)
library(randomForest)
library(ggfortify)
```

```{r}

peng_clean <- penguins %>%
  select(-island, -year, -sex) %>%
  drop_na()
peng_pc <- peng_clean %>%
  select(-species) %>%
  prcomp(x = ., center = TRUE, scale. = TRUE)

```

Example
First, using the standard kmeans algorithm on the data set we get:
```{r}
km_cluster <- kmeans(peng_clean %>% select(-species), 
                     centers = 3, iter.max = 20, nstart = 25)
peng_pc_clust <- peng_pc$x %>%
  as.data.frame() %>%
  mutate(k_clust = as.character(km_cluster$cluster),
         species = peng_clean$species)
table(peng_pc_clust %>% select(species, k_clust))

```

```{r}
autoplot(peng_pc, 
         data = peng_pc_clust,
         colour = 'k_clust')
autoplot(peng_pc, 
         data = peng_pc_clust,
         colour = 'species')

```

Next using `RandomForest` algorithm. The algorithm is run in unsupervised mode by setting the outcome variable `y = NULL`. The algorithm generates proximity matrix. This matrix gives a rough estimate of distance between samples based on the proportion of times the samples end up in same leaf node. The proximity matrix is converted to a `dist` matrix which is then input to the `hclust` algorithm. The hierarchical tree is then cut at number of `branches = 3` to obtain the final cluster assignment.

``` {r}
rf_fit <- randomForest(x = peng_clean %>% select(-species), y = NULL, 
                       ntree = 1000, proximity = TRUE, oob.prox = TRUE)
hclust_rf <- hclust(as.dist(1 - rf_fit$proximity), method = "ward.D2")
rf_cluster = cutree(hclust_rf, k = 3)

peng_pc_clust <- peng_pc_clust %>%
  mutate(rf_clust = as.character(rf_cluster))

table(peng_pc_clust %>% select(species, rf_clust))
```
```{r}
autoplot(peng_pc, 
         data = peng_pc_clust,
         colour = 'rf_clust')
```

From Briemanâ€™s original description:

> In unsupervised learning the data consist of a set of x -vectors of the same dimension with no class labels or response variables. There is no figure of merit to optimize, leaving the field open to ambiguous conclusions. The usual goal is to cluster the data - to see if it falls into different piles, each of which can be assigned some meaning.
>
> The approach in random forests is to consider the original data as class 1 and to create a synthetic second class of the same size that will be labeled as class 2. The synthetic second class is created by sampling at random from the univariate distributions of the original data. Here is how a single member of class two is created - the first coordinate is sampled from the N values {x(1,n)}. The second coordinate is sampled independently from the N values {x(2,n)}, and so forth.
>
> Thus, class two has the distribution of independent random variables, each one having the same univariate distribution as the corresponding variable in the original data. Class 2 thus destroys the dependency structure in the original data. But now, there are two classes and this artificial two-class problem can be run through random forests. This allows all of the random forests options to be applied to the original unlabeled data set.
>
> If the oob misclassification rate in the two-class problem is, say, 40% or more, it implies that the x -variables look too much like independent variables to random forests. The dependencies do not have a large role and not much discrimination is taking place. If the misclassification rate is lower, then the dependencies are playing an important role.
>
> Formulating it as a two class problem has a number of payoffs. Missing values can be replaced effectively. Outliers can be found. Variable importance can be measured. Scaling can be performed (in this case, if the original data had labels, the unsupervised scaling often retains the structure of the original scaling). But the most important payoff is the possibility of clustering.
