---
title: "Calculate cumulative impacts per species"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.height = 3, fig.width = 12)

library(raster)
library(sf)
library(tidyverse)
library(here)
library(oharac)
source(here('common_fxns.R'))

```

# Summary

On a per-species basis, we can calculate the total intensity of impacts across the species range.  We can do this per stressor, then sum.  We calculate this for the species entire range, as well as for just the coastal range, defined as those cells less than 200 meters OR including any part of the 3 nautical mile coastal buffer.

# Data

* Vulnerability scores from the trait-based vulnerability framework: Butt et al. 2021, Ecosphere.
* Species ranges from AquaMaps and IUCN Red List.
* Stressors - see stressor setup scripts.

# Methods

## Determine stressor and vulnerability matchups

| stressor                  | vulnerability                     |
|:------------------------- |:--------------------------------  |
| sst_extremes_2020         | water_temp                        |
| oa_2020                   | oa                                |
| slr_2019                  | slr                               |
| uv_2020                   | uv                                |
| fishing_benthic_dest_2017 | habitat_loss_degradation          |
| benthic_str_2020          | habitat_loss_degradation          |
| direct_human_2020         | habitat_loss_degradation          |
| shipping_large_2020       | wildlife_strike                   |
| light_2018                | light_pollution                   |
| microplastics_2015        | microplastics                     |
| bycatch_benthic_2017      | bycatch                           |
| bycatch_pelagic_2017      | bycatch                           |
| organic                   | organic_pollution                 |
| nutrient_2020             | eutrophication_nutrient_pollution |

In addition, two stressors are scored individually: targeted fishing and sea surface temperature rise.

Targeted fishing sensitivity is scored as 1 for all species (if targeted, we will find a way to efficiently catch it) modified by general adaptive capacity to determine vulnerability, and intensity of exposure is based on catch noted in Watson 2018 data.

SST rise sensitivity is scored as 1 for all species (if outside its thermal envelope, high stress) modified by general adaptive capacity to determine vulnerability.  Intensity of exposure is based on a linear increasing stressor from $T_{max,pref} = 0$ to $T_{max,abs} = 1$.

```{r}
str_vuln_lookup <- tribble(
  ~stressor,                   ~vulnerability,
   'sst_extremes_2020',         'marine_heat_waves',
   'oa_2020',                   'oa',
   'slr_2019',                  'slr',
   'uv_2020',                   'uv',
   'fishing_benthic_dest_2017', 'habitat_loss_degradation',
   'benth_str_2020',            'habitat_loss_degradation',
   'direct_human_2020',         'habitat_loss_degradation',
   'shipping_large_2021',       'wildlife_strike',
   'light_2018',                'light_pollution',
   'bycatch_benthic_2017',      'bycatch',
   'bycatch_pelagic_2017',      'bycatch',
   # 'organic',                   'organic_pollution',
   'nutrient_2020',             'eutrophication_nutrient_pollution',
   'microplastics_2015',        'plastic_pollution_microplastic',
   'sst_rise',                  'sst_rise',
   'biomass_removal',           'biomass_removal'
  )
```

## Create species x vulnerability data.frame

This will list vulnerability scores for each species that also has range information.  For species with IUCN maps, prefer those over AquaMaps.  This allows for comparing IUCN subpops where available.

```{r set up dataframe of vulnerability for mapped spp}
spp_vuln_all <- get_spp_vuln() %>%
  select(vuln = stressor, species, score) %>%
  distinct()

am_spp_all <- get_am_spp_info() %>%
  select(species = sciname, am_sid, occur_cells)
iucn_mapped <- read_csv(here('_data/iucn_spp/spp_marine_maps_2021-3.csv'))
iucn_spp_all <- read_csv(here('_data/iucn_spp/iucn_to_worms_match.csv'), show_col_types = FALSE) %>%
  select(species = worms_name, iucn_sid) %>%
  filter(iucn_sid %in% iucn_mapped$iucn_sid)

### to assign bycatch type, look at water col position. Assume benthic and pelagic
### positions are total, but benthopelagic and reef are vulnerable to both types.
spp_wcol <- read_csv(here('_data/traits_grouping/trait_water_col_position.csv'), show_col_types = FALSE) %>%
  select(species, wcol = value)

spp_vuln_mapped <- spp_vuln_all %>%
  left_join(am_spp_all,   by = 'species') %>%
  left_join(iucn_spp_all, by = 'species') %>%
  filter(!is.na(score)) %>%
  left_join(str_vuln_lookup, by = c('vuln' = 'vulnerability')) %>%
  filter(!is.na(stressor)) %>%
  left_join(spp_wcol, by = 'species') %>%
  ### zero out bycatch vulnerability based on benthic/pelagic water col position
  mutate(score = ifelse(wcol == 'benthic' & str_detect(stressor, 'bycatch_pelagic'), 0, score),
         score = ifelse(wcol == 'pelagic' & str_detect(stressor, 'bycatch_benthic'), 0, score)) %>%
  ### set source to be used for mapping:
  mutate(src = case_when(!is.na(iucn_sid) ~ 'iucn', ### prefer IUCN
                         !is.na(am_sid)   ~ 'am',   ### then AquaMaps - include even if low occur_cells
                         TRUE ~ NA_character_)) %>%
  filter(!is.na(src)) %>%
  select(-wcol, -occur_cells)

### some IUCN spp have multiple ID numbers for same spp - some due to
### synonyms adjusted based on WoRMS, some due to subpopulations
dupe_check <- spp_vuln_mapped %>%
  filter(src == 'iucn') %>%
  select(species, iucn_sid) %>%
  distinct() %>%
  group_by(species) %>%
  mutate(n_ids = n_distinct(iucn_sid)) %>%
  group_by(iucn_sid) %>%
  mutate(n_spp = n_distinct(species)) %>%
  filter(n_ids > 1 | n_spp > 1)
```

At this point, we have vulnerability information for `r n_distinct(spp_vuln_mapped$species)` species across `r n_distinct(spp_vuln_mapped$stressor)` stressors.

## Read in stressor layers

These layers have been developed in scripts found in `_setup/stressors`.  This excludes the per-spp stressors of `sst_rise` and `biomass_removal`.

```{r gather stressor rasters}
str_fs <- list.files(here('_data/stressors_mol'), pattern = '.tif', full.names = TRUE)
str_fs <- str_fs[str_detect(str_fs, paste(str_vuln_lookup$stressor, collapse = '|'))]

str_stack <- stack(str_fs) %>%
  setNames(basename(str_fs) %>% str_remove('.tif'))
```

## Loop over each species and calculate

Looping across each species:

* Collect the species range; also identify its coastal-only range.
    * If IUCN map available, use it.
    * For AquaMaps species, use presence ≥ 50%.
    * For AquaMaps species with low occur_cells, use IUCN if available, otherwise include as AquaMaps (but flagged).
* For each species:
    * mask map of stressor intensities to just those cells in spp range
    * multiply the stressor intensities by the species vulnerability
    * sum the intensity $\times$ vulnerability $\times$ cell ocean area across the entire species range
    * sum the intensity $\times$ vulnerability $\times$ cell ocean area across only the coastal portion of species range
* Assemble the values into a data.frame.
* Save out to the server - the files will be small but there will be tens of thousands, so don't keep them in GitHub.

Set up a function to process the species impacts for any given species, to be used in a loop or `parallel::mclapply()`.  This will return a dataframe of:

* stressor-vulnerability combination (character)
* total impact per stressor/vulnerability combo over entire range, in units of km^2^ * vulnerability * stressor intensity
* total impact per stressor/vulnerability combo over coastal range, in same units

Species range information (entire range and coastal range, in km^2^) will be appended to these results outside the `mclapply`.  No species information is included here; that will be included in the file name used to save the results.

### Define helper functions

* `get_spp_range(spp_id, src, thresh = .50)`
    * given a species ID (iucn_sid for IUCN, species name for AquaMaps), load the species range map.  
    * If AquaMaps, filter to probability of occurrence ≥ 50%.  
    * If IUCN, filter out extinct locations (keep only `presence` != 5)
* `get_spp_biomass_removal(spp_name, src)`
    * given a species name (all biomass removal stressors, based on catch normalized by NPP then rescaled, are stored based on species name, even for IUCN-mapped species), load the rescaled targeted catch stressor map.  
    * This will be masked to just those cells in the species range, when this is left-joined to the stressor-species intersection.
* `get_spp_sst_rise(spp_id, src)`
    * Read in the sst rise stressor based on species ID (iucn_sid or species name).
    * This should already be trimmed based on species range, but will definitely be masked when left-joined to the stressor-species intersection.

```{r set up functions to gather species range}
get_spp_range <- function(spp_id, src, thresh = .50) {

  spp_id_fix <- str_replace_all(spp_id, '[^a-z0-9]+', '_')
  src_fix <- src %>% str_remove('_.+')
  
  spp_range_f <- here_anx('spp_maps_mol', sprintf('%s_spp_mol_%s.csv', src_fix, spp_id_fix))
  spp_cells <- data.table::fread(spp_range_f) 
  if('prob' %in% names(spp_cells)) {
    spp_cells <- spp_cells %>%
      filter(prob >= thresh)
  }
  if('presence' %in% names(spp_cells)) {
    spp_cells <- spp_cells %>%
      filter(presence != 5)
  } 
  
  spp_cells <- spp_cells %>%
      select(cell_id)

  return(spp_cells)
}

get_spp_biomass_removal <- function(spp_name, src) {
  ### for IUCN, unlike other places, these are stored by sciname not IUCN sid
  biomass_rem_fstem <- here_anx('stressors/fishing/rescaled_catch_by_spp_cell', 
                                '%s_spp_rescaled_catch_%s.csv')
  
  spp_nospace <- str_replace_all(spp_name, '[^a-z]+', '_')
  src_fix <- src %>% str_remove('_.+')
  
  spp_biomass_removal_f <- sprintf(biomass_rem_fstem, src_fix, spp_nospace)
  
  if(!file.exists(spp_biomass_removal_f)) {
    ### not all spp have targeted biomass removal data
    spp_biomass_removal_cells <- data.frame(cell_id = -1, biomass_removal = 0)
  } else {
    spp_biomass_removal_cells <- data.table::fread(spp_biomass_removal_f) %>%
        rename(biomass_removal = rescaled_catch)
  }
  return(spp_biomass_removal_cells)  
}

get_spp_sst_rise <- function(spp_id, src) {
  sst_rise_fstem <- here_anx('stressors/max_temp', '%s_spp_max_temp_%s.csv')
  
  spp_id <- str_replace_all(spp_id, ' ', '_')
  src_fix <- src %>% str_remove('_.+')
  
  spp_sst_rise_f <- sprintf(sst_rise_fstem, src_fix, spp_id)
  if(!file.exists(spp_sst_rise_f)) stop('No file found: ', basename(spp_sst_rise_f))
  
  spp_sst_rise_cells <- data.table::fread(spp_sst_rise_f) %>%
    rename(sst_rise = therm_prs)
  
  return(spp_sst_rise_cells)  
}
```

Functions for processing stressors and impacts:

* `process_spp_str_intsx(tmp_vuln_df, str_df)`
    * given a dataframe of vulnerability scores for one species, and the full global stressor dataframe (cell_id vs stressor intensity)
    * get species range for this species
    * mask stressor dataframe to species range
    * append species-specific biomass removal and sst rise stressors, using left-join to effectively mask these
* summarize_spp_impact <- function(spp_str_intsx_df, area_df)
    * given the species-stressor intersection, and an area dataframe (full ocean or just coastal)
    * mask spp-str intersection to area dataframe (no masking if full ocean, or mask to coastal) - masking done with a datatable inner join.
    * for each stressor, summarize impacts as stressor intensity * vulnerability * cell area.
    * for all stressors cumulative, summarize impacts as stressor intensity * vulnerability * cell area.
    * append total range area for this range type (full or coastal).

```{r define function}

fill_missing_stressors <- function(df) {
    ### some spp are missing rows for some reason
    missing <- str_vuln_lookup %>%
      rename(vuln = vulnerability) %>%
      anti_join(df, by = c('stressor', 'vuln')) %>%
      mutate(score = 0)
    df1 <- df %>%
      bind_rows(missing) %>%
      fill(species, am_sid, iucn_sid, src)
    return(df1)
}

process_spp_str_intsx <- function(tmp_vuln_df, str_df) {
  # tmp_vuln_df <- spp_vuln_mapped %>%
  #   filter(!is.na(iucn_sid)) %>%
  #   filter(species == first(species))
  src <- tmp_vuln_df$src %>% unique()
  spp_name <- tmp_vuln_df$species %>% unique()
  iucn_sid <- tmp_vuln_df$iucn_sid %>% unique()
  
  if(any(c(length(src), length(spp_name), length(iucn_sid)) > 1)) {
    stop(sprintf('Too many rows for src %s, spp_name %s, iucn_sid %s', src, spp_name, iucn_sid))
  }
  
  spp_range <- get_spp_range(spp_id = ifelse(src == 'iucn', iucn_sid, spp_name), src)
  if(nrow(spp_range) == 0) {
    ### zero range spp
    out_df <- data.frame(cell_id = -1,
                         stressor = str_vuln_lookup$stressor,
                         intensity = 0)
    return(out_df)
  }
  
  spp_biomass_rm <- get_spp_biomass_removal(spp_name, src)
  spp_sst_rise   <- get_spp_sst_rise(spp_id = ifelse(src == 'iucn', iucn_sid, spp_name), src)
                      
  spp_str_intsx <- str_df %>%
    oharac::dt_join(spp_range, by = 'cell_id', type = 'inner') %>%
    oharac::dt_join(spp_biomass_rm, by = 'cell_id', type = 'left') %>%
    oharac::dt_join(spp_sst_rise, by = 'cell_id', type = 'left') %>%
    gather(stressor, intensity, -cell_id) %>%
    mutate(intensity = ifelse(is.na(intensity), 0, intensity))
  
  return(spp_str_intsx)
}


summarize_spp_impact <- function(spp_str_intsx, area_df) {
  spp_intsx_area_df <- spp_str_intsx %>%
    oharac::dt_join(area_df, by = 'cell_id', type = 'inner') 
  
  spp_range_km2 <- spp_intsx_area_df %>%
    select(cell_id, ocean_a_km2) %>%
    distinct() %>%
    summarize(range_a_km2 = sum(ocean_a_km2), .groups = 'drop') %>%
    .$range_a_km2
  
  imp_by_str <- spp_intsx_area_df %>%
    group_by(vuln, stressor) %>%
    summarize(impact_tot = sum(intensity * score * ocean_a_km2), .groups = 'drop')
  imp_cum <- spp_intsx_area_df %>%
    summarize(vuln = 'cumulative', stressor = 'cumulative', 
              impact_tot = sum(intensity * score * ocean_a_km2), .groups = 'drop')
  impact_df <- imp_by_str %>%
    bind_rows(imp_cum) %>%
    mutate(range_km2 = spp_range_km2)

  return(impact_df)
}
```

```{r set up ocean area and stressor dataframes}
ocean_a_rast <- raster(here('_spatial/ocean_area_mol.tif'))
ocean_a_df <- data.frame(ocean_a_km2 = values(ocean_a_rast) * 100) %>%
  mutate(cell_id = 1:n()) %>%
  filter(!is.na(ocean_a_km2))

coastal_a_rast <- raster(here('_spatial/bathy_mol_neritic.tif'))
coastal_a_df <- data.frame(ocean_a_km2 = values(ocean_a_rast) * 100,
                           coastal = values(coastal_a_rast)) %>%
  mutate(cell_id = 1:n()) %>%
  filter(!is.na(coastal)) %>%
  select(cell_id, ocean_a_km2)

str_df <- data.frame(values(str_stack)) %>%
  mutate(cell_id = 1:n()) %>%
  filter(cell_id %in% ocean_a_df$cell_id)

```

### Loop over AquaMaps species

``` {r process am spp}
am_spp_vec <- spp_vuln_mapped %>%
  filter(str_detect(src, 'am')) %>%
  .$species %>% unique()

out_fstem <- here_anx('impacts_by_species/impacts_am_%s.csv')

am_spp_vec <- am_spp_vec[!file.exists(sprintf(out_fstem, str_replace_all(am_spp_vec, ' ', '_')))]

chunk_size <- 100
n_chunks <- ceiling(length(am_spp_vec) / chunk_size)

for(k in 1:n_chunks) {
  ### k <- 1
  ptm_k <- proc.time()
  
  ### Chunk out large species-cell dataframe into smaller bits for
  ### quicker filtering at the species level.
  i_min <- (k-1) * chunk_size + 1
  i_max <- min(k * chunk_size, length(am_spp_vec))
  
  chunk_spp_vec <- am_spp_vec[i_min:i_max]
  
  ### check that some of these spp still need to be processed, otherwise
  ### skip to the next chunk:
  chunk_spp_files <- sprintf(out_fstem, str_replace_all(chunk_spp_vec, ' ', '_'))
  if(all(file.exists(chunk_spp_files))) {
    message('All spp in chunk ', k, ' already have impact files... skipping!')
    next()
  } else {
    chunk_spp_vec <- chunk_spp_vec[!file.exists(chunk_spp_files)]
  }
  
  tmp <- parallel::mclapply(seq_along(chunk_spp_vec),
                            mc.cores = 34,
                            FUN = function(i) {
      ### i <- 1
      ### i <- which(chunk_spp_vec == 'abyssaster planus')
      ptm_i <- proc.time()
      spp <- chunk_spp_vec[i]
  
      outfile <- sprintf(out_fstem, str_replace_all(spp, ' ', '_'))
      
      if(file.exists(outfile)) {
        # message('File ', outfile, ' exists... skipping!')
        return()
      }
      
      message(i, ' of ', length(chunk_spp_vec), ', chunk ', k, ' of ', n_chunks, 
              ': processing impacts on AM ', spp %>% unique(), '...')
      
      spp_am_vuln <- spp_vuln_mapped %>%
        filter(species == spp) %>%
        fill_missing_stressors() %>%
        ### drop confounding IDs
        select(-iucn_sid, -am_sid) %>%
        distinct()
      
      spp_str_intsx <- process_spp_str_intsx(spp_am_vuln, str_df) %>%
        oharac::dt_join(spp_am_vuln %>% select(vuln, stressor, score), 
                        by = 'stressor', type = 'left')
      
      ### calc sum of impacts by str and cum over full range and coastal range
      imp_full_range <- summarize_spp_impact(spp_str_intsx, ocean_a_df) %>%
        mutate(range = 'full')
      imp_coastal_range <- summarize_spp_impact(spp_str_intsx, coastal_a_df) %>%
        mutate(range = 'coastal')
      
      ### bind rows, add total and coastal ranges, and write out
      spp_impacts_df <- bind_rows(imp_full_range, imp_coastal_range)

      write_csv(spp_impacts_df, outfile)
      
      message(i, ' of ', length(chunk_spp_vec), ', chunk ', k, ' of ', n_chunks, 
              ': processed impacts on ', spp,
              '... elapsed time: ', round(proc.time() - ptm_i, 3)[3], 's.')
    })
  
  message('Chunk time to process: ', round(proc.time() - ptm_k, 3)[3], 's.')
  
}

```

### Loop over IUCN species

``` {r process iucn spp}
iucn_spp_vec <- spp_vuln_mapped %>%
  filter(str_detect(src, 'iucn')) %>%
  .$iucn_sid %>% unique()

out_fstem <- here_anx('impacts_by_species/impacts_iucn_%s.csv')

iucn_spp_vec <- am_spp_vec[!file.exists(sprintf(out_fstem, str_replace_all(iucn_spp_vec, ' ', '_')))]

chunk_size <- 100
n_chunks <- ceiling(length(iucn_spp_vec) / chunk_size)
out_fstem <- here_anx('impacts_by_species/impacts_iucn_%s.csv')

for(k in 1:n_chunks) {
  ### k <- 1
  ### k <- ceiling(which(iucn_spp_vec == 192271) / 100)
  ptm_k <- proc.time()
  
  ### Chunk out large species-cell dataframe into smaller bits for
  ### quicker filtering at the species level.
  i_min <- (k-1) * chunk_size + 1
  i_max <- min(k * chunk_size, length(iucn_spp_vec))
  
  chunk_spp_vec <- iucn_spp_vec[i_min:i_max]
  
  ### check that some of these spp still need to be processed, otherwise
  ### skip to the next chunk:
  chunk_spp_files <- sprintf(out_fstem, chunk_spp_vec)
  if(all(file.exists(chunk_spp_files))) {
    message('All spp in chunk ', k, ' already have impact files... skipping!')
    next()
  } else {
    chunk_spp_vec <- chunk_spp_vec[!file.exists(chunk_spp_files)]
  }
  
  tmp <- parallel::mclapply(seq_along(chunk_spp_vec),
                            mc.cores = 34,
                            FUN = function(i) {
      ### i <- 1
      ### i <- which(chunk_spp_vec == 192271)
      ptm_i <- proc.time()
      spp <- chunk_spp_vec[i]
  
      outfile <- sprintf(out_fstem, str_replace_all(spp, ' ', '_'))
      
      if(file.exists(outfile)) {
        # message('File ', outfile, ' exists... skipping!')
        return()
      }
      
      message(i, ' of ', length(chunk_spp_vec), ', chunk ', k, ' of ', n_chunks, 
              ': processing impacts on IUCN ', spp %>% unique(), '...')
      
      spp_iucn_vuln <- spp_vuln_mapped %>%
        filter(iucn_sid == spp) %>%
        fill_missing_stressors() %>%
        ### drop confounding IDs
        select(-am_sid) %>%
        distinct() %>%
        ### for cases where multiple WoRMS-adjusted spp names assigned to one iucn_sid
        ### (a few cones and corals, with low to no fishing pressure)
        filter(species == first(species))
      
      spp_str_intsx <- process_spp_str_intsx(spp_iucn_vuln, str_df) %>%
        oharac::dt_join(spp_iucn_vuln %>% select(vuln, stressor, score), 
                        by = 'stressor', type = 'left')
      
      ### calc sum of impacts by str and cum over full range and coastal range
      imp_full_range <- summarize_spp_impact(spp_str_intsx, ocean_a_df) %>%
        mutate(range = 'full')
      imp_coastal_range <- summarize_spp_impact(spp_str_intsx, coastal_a_df) %>%
        mutate(range = 'coastal')
      
      ### bind rows, add total and coastal ranges, and write out
      spp_impacts_df <- bind_rows(imp_full_range, imp_coastal_range)

      write_csv(spp_impacts_df, outfile)
      
      message(i, ' of ', length(chunk_spp_vec), ', chunk ', k, ' of ', n_chunks, 
              ': processed impacts on ', spp,
              '... elapsed time: ', round(proc.time() - ptm_i, 3)[3], 's.')
    })
  
  message('Chunk time to process: ', round(proc.time() - ptm_k, 3)[3], 's.')
  
}

```



