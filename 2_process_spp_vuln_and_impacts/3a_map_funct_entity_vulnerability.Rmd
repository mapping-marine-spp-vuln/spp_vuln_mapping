---
title: "Map vulnerability (by functional entity, functional vulnerability weighted)"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.height = 3, fig.width = 12)

library(terra)
library(oharac)
library(data.table)
library(tidyverse)
library(here)
source(here('common_fxns.R'))
```

# Summary

Apply vulnerability scores to mapped species.  Map out vulnerability to each stressor, first by species (each spp counts same, previous script), then to functional entities, weighted by functional vulnerability (FEs with higher FV are given greater weight, this script).  This script only includes species categorized into a functional entity.

# Data

* AquaMaps and IUCN rangemaps
* Vulnerability Framework data for vulnerability scores
* FishBase/SeaLifeBase and vulnerability framework data for functional entity assignments

# Methods

Read in AquaMaps and IUCN maps and vulnerability scores.  AquaMaps maps will exclude species with fewer than 10 occurrence cells, and will use a probability threshold of 0.5.

To calculate functional vulnerability of species within a cell, we must know all species in that cell (and their FE membership).  But loading in all spp maps simultaneously will likely be too memory intensive.  Because of the number of cells and species, we will break the map into chunks of e.g., 100,000 cells at a time.  For each chunk, we will read in each species map, filtering to the chunk cells only to keep the memory needs down, bind the lookup of species-to-functional entity, calculate functional vulnerability for each FE for each cell.  Then, iterating over each stressor, for that chunk, calculate FV-weighted mean and sd vulnerability (as well as total FV weight value).  Then bind rows for all chunks per stressor.

## Set up dataframe of species

This includes information on species vulnerability scores, functional entity ID and traits, as well as which species are mapped in which sources (including rangemap filenames).

```{r assemble spp info dataframe}
spp_info_df <- assemble_spp_info_df(fe_only = TRUE) %>%
  rename(vulnerability = stressor)
```

## Set up functions to process the various steps

To calc functional vulnerability, we need to know ALL species in each cell (and their FE membership).  So we will process maps in chunks, collecting all spp but cropping down their range to just those cells in the chunk.

```{r}

read_truncated_rangemap <- function(f, chunk_start, chunk_end) {
  ### f <- spp_map_fs$map_f[13]

  ### Identify the source from filename (for filtering by presence or prob)
  src <- ifelse(str_detect(basename(f), 'iucn_spp_mol'), 'iucn', 'am')
  df <- data.table::fread(f) %>%
    filter(between(cell_id, chunk_start, chunk_end)) %>%
    mutate(map_f = f)
  if(src == 'iucn') {
    df <- df %>%
      filter(presence != 5) %>% 
      select(-presence)
  } else {
    df <- df %>%
      filter(prob >= .5) %>%
      select(-prob)
  }
  if(nrow(df) == 0) return(NULL) else return(df)
}

bind_maps_list <- function(chunk_maps_list, spp_map_fs) {
  if(check_tryerror(chunk_maps_list)) {
    stop('Try-error found when binding truncated maps list!')
  }

  chunk_maps_raw <- chunk_maps_list %>%
    ### drop NULL instances (no spp cells - helps keep things from crashing)
    purrr::compact() %>% 
    data.table::rbindlist() 
  
  if(nrow(chunk_maps_raw) > 0) {
    ### if no spp-cell data for this chunk, skip bind and return 0-length df
    chunk_maps_raw <- chunk_maps_raw %>%
      oharac::dt_join(spp_map_fs, by = 'map_f', type = 'left') %>%
      select(-map_f) %>%
      distinct()
  }
  return(chunk_maps_raw)
}
```

Functional vulnerability for a functional entity will be calculated based on the number of species $N_{spp}$ in the FE:

$$FV_{FE} = \frac{1}{2^{N_{spp}-1}}$$
The formulation by Sebastien Villeger calculates $FV$ as the proportion of FEs represented by only a single species.  This new formulation accounts for vulnerability of FEs with low membership, and quickly drops off as membership increases - e.g., an FE with two members is given FV of 0.5, while an FE with ten members is given FV of 0.002. 

Overall functional vulnerability of a cell will be the average of FV across all $N_{FE}$ FEs in the cell:
$$FV = \frac{\sum FV_{FE}}{N_{FE}}$$

Using the Villeger metric ($FV_i \in \{0, 1\}$) this simplifies to the proportion of FEs represented by a single species.

Then, the FV-weighted mean vulnerability $V_{FV}^{s,i}$ of a functional entity $i$ to a stressor $s$ is calculated as the average stressor vulnerability $v_s$ of all spp $j \in 1:N_{spp,i}$in that FE, times the functional vulnerability:
$$V_{FV}^{s,i} = FV_i \times \frac{1}{N_{spp,i}}\sum_{j=1}^{N_{spp,i}} v_{s,j} = FV_i \times \bar v_s$$
Using the Villeger metric ($FV_i \in \{0, 1\}$), $V_{FV}^{s,i}$ is zero for FEs with $N_{spp,i} > 1$ and equal to $v_{s,1}$ for FEs with $N_{spp,i} = 1$.

The cell overall FV-weighted mean vulnerability to stressor $s$ is:
$$V_{FV}^{s} = \frac{1}{\sum_{k=1}^{N_{FE}} FV_k} \sum_{i=1}^{N_{FE}} FV_i \times \bar v_s = \frac{1}{\sum_{k=1}^{N_{FE}} FV_k} \sum_{i=1}^{N_{FE}} V_{FV}^{s,i}$$

#### Note on mean and sd:

When working with unweighted vulnerabilities (with species counts) we could take a pooled variance approach to determining the standard deviation of vulnerability across all species present in a cell.  Here, the unit of analysis is a functional entity, and weighted not by the number of species in each FE but rather by the functional vulnerability of that FE.  A weighted pooled variance may be possible, but here we will simply report the FV-weighted mean across all FEs in the cell, and standard deviation of FV-weighted mean across all FEs.  This loses information on variance of vulnerability within each FE but that may not be that interesting or critical.

```{r function for processing vulnerability}

mc_process_vuln_chunk <- function(spp_maps_df, spp_vuln_info_df) {

  chunk_spp_scores <- spp_vuln_info_df %>%
    filter(species %in% chunk_maps$species) %>%
    select(species, v_score) %>%
    distinct()
  
  cell_id_df <- data.frame(cell_id = chunk_maps$cell_id %>% unique()) %>%
    mutate(cell_gp = rep(1:100, length.out = n()))
  cell_gps <- cell_id_df$cell_gp %>% unique()

  chunk_spp_vuln_maps <- chunk_maps %>%
    oharac::dt_join(chunk_spp_scores, by = 'species', type = 'inner') 
  
  ### parallelize for speed! balance vectorization with parallel to reduce crashing...
  chunk_vuln_sum_list <- parallel::mclapply(cell_gps, mc.cores = 25,
          FUN = function(gp) { ### gp <- 2
            cell_ids <- cell_id_df %>% filter(cell_gp == gp) %>% .$cell_id
            
            df <- chunk_spp_vuln_maps %>%
              filter(cell_id %in% cell_ids) %>%
              data.table() %>%
              .[ , .(score_mean = mean(v_score), # %>% round(5),
                     score_sd   = sd(v_score), # %>% round(5),
                     ### super-tiny fv (~ 1e-20) result in Inf var
                     fv = first(fv) %>% round(10)),
                 by = .(cell_id, fe_id)] %>%
              .[ , .(n_fe = n_distinct(fe_id),
                     fv_mean = mean(fv),
                     fv_wt_mean_vuln = Hmisc::wtd.mean(score_mean,     weights = fv),
                     fv_wt_sd_vuln   = sqrt(Hmisc::wtd.var(score_mean, weights = fv))),
                 by = .(cell_id)]
          })
  if(check_tryerror(chunk_vuln_sum_list)) {
    stop('Try error results in mc_process_vuln_chunk for vuln ', vuln, '...')
  }
  chunk_vuln_sum_df <- data.table::rbindlist(chunk_vuln_sum_list)
  return(chunk_vuln_sum_df)
}
```

## Set up loop over chunks of cells, then vulnerability layers

For each chunk of cells, save out temp files of each vulnerability layer - fv-weighted mean, fv-weighted sd, number of functional entities, mean functional vulnerability across FEs - to be combined later.

```{r big ass loop}

vuln_vec <- spp_info_df$vulnerability %>% unique()

spp_map_fs <- spp_info_df %>%
  select(species, map_f) %>%
  distinct() 
spp_fe <- spp_info_df %>%
  select(species, fe_id) %>%
  distinct()

chunk_size <- 100000
n_chunks <- ceiling(6.5e6 / chunk_size)

tmp_stem <- here('tmp/vuln_fe_wt_chunks/vuln_summary_chunk_%s_to_%s_%s.csv')
  ### format will be: chunk start, chunk end, vulnerability
### zxcv <- list.files(dirname(tmp_stem), full.names = TRUE)
### unlink(zxcv)

for(chunk_i in 1:n_chunks) { 
  ### chunk_i <- 1
  ### chunk_i <- 30
  
  ### Set up chunk start and end and filenames; check whether maps 
  ### all stressors for this chunk...
  chunk_start <- (chunk_i - 1) * chunk_size + 1
  chunk_end   <- as.integer(chunk_i * chunk_size)
  chunk_text  <- sprintf('chunk %s of %s (cells %s to %s)', 
                         chunk_i, n_chunks, chunk_start, chunk_end)

  ### check if all chunk-stressor maps are complete
  tmp_f_all_vulns <- sprintf(tmp_stem, chunk_start, chunk_end, vuln_vec)
  if(all(file.exists(tmp_f_all_vulns))) {
    message('All vulnerability summaries exist for ', chunk_text, '... skipping!')
    next()
  }
  
  ### Passed the test - therefore, some chunk maps remain, so continue:
  ### Load species rangemaps for this chunk, then clean and bind:
  message('Loading ', nrow(spp_map_fs), ' rangemaps cropped for ', chunk_text,  '...')
  
  chunk_maps_list <- parallel::mclapply(spp_map_fs$map_f, mc.cores = 40, 
                                        FUN = read_truncated_rangemap, 
                                        chunk_start = chunk_start, chunk_end = chunk_end) 
  
  chunk_maps_raw <- bind_maps_list(chunk_maps_list, spp_map_fs)
  
  ### OK, now we have species and cells for this chunk.  Calculate functional vulnerability!
  message('Calculating functional vulnerability metrics for ', nrow(chunk_maps_raw), 
          ' spp-cells in ', chunk_text, '...')
  chunk_maps <- chunk_maps_raw %>%
    calc_spp_cell_fv(spp_fe)
  
  message('In ', chunk_text,  ' rangemap dataframe: \n    ', nrow(chunk_maps), 
          ' cell observations for ', n_distinct(chunk_maps$species), ' species across ',
          n_distinct(chunk_maps$fe_id), ' functional entities...')


  ### For this chunk, loop over all stressors, summarize FV-weighted mean and sd
  for(v in vuln_vec) {
    ### v <- vuln_vec[21]
    tmp_f_this_str <- sprintf(tmp_stem, chunk_start, chunk_end, v)
    if(file.exists(tmp_f_this_str)) {
      message('Temp csv exists for ', chunk_text, ' for vuln ', v, '... skipping!')
      next()
    }

    message('Processing mean/sd vuln in ', chunk_text, ' to vuln: ', v)
    spp_vuln_info_df <- spp_info_df %>% filter(vulnerability == v)
    chunk_vuln_sum <- mc_process_vuln_chunk(chunk_maps, spp_vuln_info_df)
    
    write_csv(chunk_vuln_sum, tmp_f_this_str)
  }
}

```

### Aggregate temp vuln maps to all species

Gather all the temp files, and loop over vulnerabilities to combine into a single map; then convert to raster and save out for FV-weighted mean, FV-weighted sd, and number of functional entities.

```{r assemble taxon vuln maps to total maps}
chunk_sum_df <- data.frame(f = list.files(dirname(tmp_stem), full.names = TRUE,
                                          pattern = 'vuln_summary_chunk')) %>%
  mutate(v = str_extract(basename(f), paste0(vuln_vec, collapse = '|')))

out_stem <- here('_output/vuln_maps/vuln_maps_by_funct_entity/vuln_fe_%s_%s.tif')
  ### format will be: vuln, parameter (mean, sd, n_fe, mean_fv)

for(vuln in vuln_vec) {
  ### vuln <- vuln_vec[21]
  
  ### check if total vuln maps are complete
  params <- c('mean', 'sdev', 'n_fe', 'mean_fv')
  outfiles <- sprintf(out_stem, vuln, params) %>%
    setNames(params)

  if(all(file.exists(outfiles[c('mean', 'sdev')]))) {
    ### n_fe and mean_fv rasts are collected into a single final file later
    ###  in the script; don't recreate those if the other two exist!
    message('All FV-weighted summary rasters exist for vuln ', vuln, '... skipping!')
    next()
  }
  
  ### Combine mean, sdev, and n_fe maps by taxon into one big dataframe
  message('Processing mean, sd, n_fe maps across all species for ', vuln, '...')
  vuln_sum_df <- chunk_sum_df %>%
    filter(v == vuln)
  vuln_stats_list <- parallel::mclapply(vuln_sum_df$f, mc.cores = 33, 
                               FUN = read_csv, show_col_types = FALSE)
  if(check_tryerror(vuln_stats_list)) {
    stop('Encountered try-error in reading FV-weighted vuln summary files...')
  }
  vuln_stats_df <- vuln_stats_list %>%
    data.table::rbindlist()
  
  mean_rast <- map_to_mol(vuln_stats_df, which = 'fv_wt_mean_vuln')
  sdev_rast <- map_to_mol(vuln_stats_df, which = 'fv_wt_sd_vuln')
  n_fe_rast <- map_to_mol(vuln_stats_df, which = 'n_fe')
  mean_fv_rast <- map_to_mol(vuln_stats_df, which = 'fv_mean')
    
  writeRaster(mean_rast, outfiles['mean'], overwrite = TRUE)
  writeRaster(sdev_rast, outfiles['sdev'], overwrite = TRUE)
  writeRaster(n_fe_rast, outfiles['n_fe'], overwrite = TRUE)
  writeRaster(mean_fv_rast, outfiles['mean_fv'], overwrite = TRUE)
}

```

### Check functional richness maps

These should all be the same.  If so, copy one to the main output and delete the rest as redundant.

```{r check functional richness}
n_fe_main_out_f <- here('_output/nspp_maps/funct_entity_richness.tif')
n_fe_vuln_fs <- list.files(dirname(out_stem), pattern = 'n_fe.tif', full.names = TRUE)

if(!file.exists(n_fe_main_out_f)) {
  ### create the main spp richness raster from vuln-level richness rasters,
  ### which *should* all be identical.
  
  if(length(n_fe_vuln_fs) < length(vuln_vec)) {
    stop('Functional entity count raster ', basename(n_fe_main_out_f), ' is missing, but ',
         'not all vuln-level FE count maps are available!')
  }
  
  n_fe_list <- lapply(n_fe_vuln_fs, raster::raster)
    
  ### if not all equal, this throws an error - stop and figure out why
  raster::compareRaster(n_fe_list, values = TRUE, stopiffalse = TRUE)

  ### all are equal, so copy one to n_fe_main_out_f and delete the vuln-level ones
  writeRaster(n_fe_list[[1]], n_fe_main_out_f, overwrite = TRUE)
  unlink(n_fe_vuln_fs)
  
} else if(length(n_fe_vuln_fs) > 0) {
  ### verify that the main out file is the same as any vuln-level ones
  n_fe_main <- raster(n_fe_main_out_f)
  n_fe_list <- lapply(n_fe_vuln_fs, raster)
    
  ### if not all equal, this throws an error - stop and figure out why
  compareRaster(n_fe_list, values = TRUE, stopiffalse = TRUE)
  compareRaster(n_fe_main, n_fe_list[[1]], values = TRUE, stopiffalse = TRUE)
  
  ### if all good, delete the vuln-level maps as redundant
  unlink(n_fe_vuln_fs)

}

```

### Check functional vulnerability maps

As for the number of FEs, the functional vulnerability should remain the same regardless of vulnerability type.  If so, copy one to the main output and delete the rest as redundant.

```{r check funct vuln maps}
mean_fv_main_out_f <- here('_output/nspp_maps/mean_funct_vulnerability.tif')
mean_fv_vuln_fs <- list.files(dirname(out_stem), pattern = 'mean_fv.tif', full.names = TRUE)

if(!file.exists(mean_fv_main_out_f)) {
  ### create the main spp richness raster from vuln-level richness rasters,
  ### which *should* all be identical.
  
  if(length(mean_fv_vuln_fs) < length(vuln_vec)) {
    stop('Functional vuln raster ', basename(mean_fv_main_out_f), ' is missing, but ',
         'not all vuln-level FV maps are available!')
  }
  
  ### use compareRaster from raster package
  mean_fv_list <- lapply(mean_fv_vuln_fs, raster::raster)
    
  ### if not all equal, this throws an error - stop and figure out why
  check_mean_fv <- raster::compareRaster(mean_fv_list, values = TRUE, stopiffalse = TRUE)
  
  ### all are equal, so copy one to mean_fv_main_out_f and delete the vuln-level ones
  writeRaster(mean_fv_list[[1]], mean_fv_main_out_f, overwrite = TRUE)
  unlink(mean_fv_vuln_fs)
  
} else if(length(mean_fv_vuln_fs) > 0) {
  ### main out file already exists, but vuln-level files also exist;
  ### verify that the main out file is the same as any (new) vuln-level ones
  mean_fv_main <- raster::raster(mean_fv_main_out_f)
  mean_fv_list <- lapply(mean_fv_vuln_fs, raster::raster)
    
  ### if not all equal, this throws an error - stop and figure out why
  raster::compareRaster(mean_fv_list, values = TRUE, stopiffalse = TRUE)
  raster::compareRaster(mean_fv_main, mean_fv_list[[1]], values = TRUE, stopiffalse = TRUE)
  
  ### if all good, delete the vuln-level maps as redundant
  unlink(mean_fv_vuln_fs)

}

```



## Plot example maps

```{r plot vulns, fig.height = 4, fig.width = 7}

vuln_spp_dir <- here('_output/vuln_maps/vuln_maps_by_funct_entity')
mean_fs <- list.files(vuln_spp_dir, pattern = '_mean.tif', full.names = TRUE)
sdev_fs <- list.files(vuln_spp_dir, pattern = '_sdev.tif', full.names = TRUE)

focal_strs <- c('biomass_removal', 'bycatch', 
                'microplastic', 'wildlife_strike',
                'nutrient_pollution', 'ocean_acidification', 
                'sst_rise', 'marine_heat_wave',
                'light_pollution')

for(f in focal_strs) { ### f <- focal_strs[1]
  mean_f <- mean_fs[str_detect(basename(mean_fs), f)]
  sdev_f <- sdev_fs[str_detect(basename(sdev_fs), f)]
  mean_rast <- raster::raster(mean_f)
  sdev_rast <- raster::raster(sdev_f)
  # sd_stack   <- raster::stack(sd_fs) %>%
  #   setNames(str_remove(names(.), 'vuln_by_spp_'))
  
  map_cols <- hcl.colors(n = 50)
  
  plot(mean_rast, zlim = c(0, 1), col = map_cols, main = paste0('Mean vuln: ', f),
       legend = FALSE, axes = FALSE)  
  # plot(sdev_rast, zlim = c(0, 1), col = map_cols, main = paste0('SD vuln: ', f),
  #      legend = FALSE, axes = FALSE)
}
```
