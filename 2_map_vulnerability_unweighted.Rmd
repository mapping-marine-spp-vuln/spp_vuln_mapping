---
title: "Map vulnerability"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(raster)
library(oharac)
library(tidyverse)
library(here)
source(here('common_fxns.R'))

```

# Summary

Apply vulnerability scores to mapped species.  Map out vulnerability to each stressor, first unweighted by species (each spp counts same), then unweighted by functional entity (each functional entity counts same), then weighted by functional vulnerability (FEs with higher FV are given greater weight).

# Data

* AquaMaps and IUCN rangemaps
* Vulnerability Framework data for vulnerability scores
* FishBase/SeaLifeBase and vulnerability framework data for functional entity assignments

# Methods

## Unweighted, by species

Read in AquaMaps and IUCN maps and vulnerability scores.  AquaMaps maps will exclude species with fewer than 10 occurrence cells, and will use a probability threshold of 0.5.  Here, we can include all species in the intersection of (mapped $\cap$ trait-based vulnerability) without worrying about functional entity membership.

Iterating over each stressor, calculate cell-by-cell mean (and standard deviation?).

* At the 10 km Mollweide resolution, rather than HCAF resolution, we will probably have to chunk this out and then add the pieces together.
* Processing by taxonomic group first, then combining.

```{r}
spp_am <- get_am_spp_info()  %>%
  filter(occur_cells >= 10) %>%
  select(species = sciname) %>%
  mutate(am_mapped = TRUE) %>%
  distinct()

spp_iucn <- read_csv(here('_data/iucn_spp/iucn_to_worms_match.csv'), show_col_types = FALSE) %>%
  rename(species = worms_name, iucn_mapped = mapped)

spp_vuln <- get_spp_vuln(gapfill = 'family') %>%
  select(species, stressor, taxon, score, sd_score)  %>%
  mutate(vuln = TRUE) %>%
  distinct()

spp_worms <- assemble_worms() %>%
  select(species) %>%
  mutate(worms = TRUE) %>%
  distinct()

all_spp <- spp_worms %>%
  full_join(spp_vuln, by = 'species') %>%
  full_join(spp_am,   by = 'species') %>%
  full_join(spp_iucn, by = 'species')

spp_for_vuln_calc <- all_spp %>%
  ### names in WoRMS
  filter(worms) %>%
  ### only those spp in vulnerability project?
  filter(vuln) %>%
  ### mapped in AquaMaps and/or IUCN
  filter(am_mapped | iucn_mapped)

```


### Taxon-by-taxon vulnerability maps

Loop over each stressor, then over each taxon.  Generate a mean and sd vulnerability map for each combination; save to Mazu.

```{r vuln by species iterating over stressors and taxa}

strs <- spp_for_vuln_calc$stressor %>% unique() %>% sort()
taxa <- spp_for_vuln_calc$taxon %>% unique() %>% sort()

# spp_for_vuln_calc %>%
#   group_by(taxon) %>%
#   summarize(n_spp = n_distinct(species))

out_stem <- here_anx('vuln_maps/vuln_by_species/vuln_by_str_tx/vuln_tx_%s_%s_%s.tif')
  ### format will be: taxon, stressor, parameter (mean or sd)

### unlink(list.files(here('_output/vuln_by_spp'), full.names = TRUE))

for(t in taxa) {
  ### t <- taxa[6]
  
  ### check if all taxon-stressor maps are complete
  outf_mean_all_strs <- sprintf(out_stem, t, strs, 'mean')
  outf_sdev_all_strs <- sprintf(out_stem, t, strs, 'sdev')
  if(all(file.exists(outf_mean_all_strs, outf_sdev_all_strs))) {
    message('All stressor rasters exist for taxon ', t, '... skipping!')
    next()
  }
  
  ### Some taxon-stressor maps remain, so continue:
  ### Load species rangemaps for this taxon
  ### identify spp and map sources for this taxon
  spp_map_fstem <- here_anx('spp_maps_mol', '%s_spp_mol_%s.csv')

  tx_spp <- spp_for_vuln_calc %>%
    filter(taxon == t) %>%
    select(species, am_mapped, iucn_mapped, iucn_sid) %>%
    distinct() %>%
    mutate(src = ifelse(iucn_mapped & !is.na(iucn_mapped), 'iucn', 'am'),
           id  = ifelse(src == 'iucn', iucn_sid, str_replace_all(species, ' ', '_')),
           map_f = sprintf(spp_map_fstem, src, id)) %>%
    select(species, src, map_f) %>%
    distinct()
  
  ### load IUCN and AquaMaps maps for this taxon; flatten to presence = 1
  message('Loading ', nrow(tx_spp), ' rangemaps for taxon ', t, '...')
  tx_maps <- parallel::mclapply(tx_spp$map_f, mc.cores = 40, 
                  ### f <- tx_spp$map_f[1]
                  FUN = function(f) {
                    src <- ifelse(str_detect(basename(f), 'iucn_spp_mol'), 'iucn', 'am')
                    df <- data.table::fread(f)
                    if(src == 'iucn') {
                      df <- df %>%
                        filter(presence != 5) %>% 
                        select(-presence)
                    } else {
                      df <- df %>%
                        filter(prob >= .5) %>%
                        select(-prob)
                    }
                    return(df)}) %>%
    setNames(tx_spp$species) %>%
    bind_rows(.id = 'species') %>%
    distinct()
  message('Taxon ', t, ' rangemap dataframe: ', nrow(tx_maps), 
          ' cell observations for ', nrow(tx_spp), ' species...')

  for(s in strs) {
  ### s <- strs[2]
    outf_mean <- sprintf(out_stem, t, s, 'mean')
    outf_sdev <- sprintf(out_stem, t, s, 'sdev')
    outf_nspp <- sprintf(out_stem, t, s, 'nspp')
    if(all(file.exists(outf_mean, outf_sdev, outf_nspp))) {
      message('Rasters exist for taxon ', t, ' for stressor ', s, '... skipping!')
      next()
    }
    ### identify species vulnerability for this stressor
    ### multiply each species map by vulnerability to this stressor
    ### calculate mean and sd per cell
    
    message('Processing mean/sd vulnerability by species in taxon ', t, ' to stressor: ', s)
    tx_spp_str_vuln <- spp_for_vuln_calc %>%
      filter(stressor == s & taxon == t) %>%
      select(species, score, sd_score) %>%
      distinct()
    
    ### because failures might occur with summarizing a huge dataset,
    ### let's break this into chunks by cell_id - there are 6.6e+06 cells total
    ### note - this is probably really only necessary for fish with 10k+ species
    chunk_size <- 500000
    n_chunks <- ceiling(ncell(raster::raster(here('_spatial/ocean_area_mol.tif'))) / chunk_size)
    # system.time({
    result_df <- parallel::mclapply(1:n_chunks, mc.cores = 1, ### memory constrained
                   FUN = function(n) { ### n <- 1
                     cell_id_min <- (n - 1) * chunk_size + 1
                     cell_id_max <- n * chunk_size
                     message('Summarizing stressor ', s, ' on taxon ', t, 
                             ': cells ', cell_id_min, ' - ', cell_id_max, '...')

                     chunk_sum <- tx_maps %>%
                       filter(between(cell_id, cell_id_min, cell_id_max)) %>%
                       oharac::dt_join(tx_spp_str_vuln, by = 'species', type = 'inner') %>%
                       group_by(cell_id) %>%
                       summarize(score_mean = mean(score) %>% round(5),
                                 score_sd   = sd(score) %>% round(5),
                                 n_spp      = n_distinct(species),
                                 .groups = 'drop')
                     }) %>%
      bind_rows() %>%
      filter(!is.na(cell_id))
    
    rast_mean <- map_to_mol(result_df, which = 'score_mean')
    rast_sd   <- map_to_mol(result_df, which = 'score_sd')
    rast_nspp <- map_to_mol(result_df, which = 'n_spp')
    
  
    writeRaster(rast_mean, outf_mean, overwrite = TRUE)
    writeRaster(rast_sd,   outf_sdev, overwrite = TRUE)
    writeRaster(rast_nspp, outf_nspp, overwrite = TRUE)
  }
}

```

### Aggregate taxon stressor maps to all species

For each stressor, pull in all taxon rasters, assemble into dataframe, and summarize to aggregate mean, sd, and nspp.  This will require a pooled variance approach to backing out the standard deviation.

Pooled variance formula when variances not necessarily equal (from one of the responses [here](https://math.stackexchange.com/questions/2971315/how-do-i-combine-standard-deviations-of-two-groups))

$$s^2_{x_1 \cup x_2} = \frac{(n_1-1)s^2_{x_1} + (n_2-1)s^2_{x_2}}{(n_1+n_2-1)} + 
\frac{n_1 n_2(\bar x_1 - \bar x_2)^2}{(n_1+n_2)(n_1+n_2-1)}$$

But how does this formula work for multiple groups?  Seems like the correction factor gets increasingly complicated, but a sequential calculation, each time taking the result from one combo and combining it with a new set, should work.  Here I define a function for a two-sample pooled variance, and then an iterated version that sequentially pools elements into the larger pool.

```{r pooled var function and test}

pooled_var <- function(x_bar, y_bar, s_x, s_y, n_x, n_y) {
  ### convert std dev to var
  var_x <- ifelse(is.na(s_x), 0, s_x^2)
  var_y <- ifelse(is.na(s_y), 0, s_y^2)

  var_xy_clean <- ((n_x - 1)*var_x + (n_y - 1)*var_y) / (n_x + n_y - 1)
  var_xy_error <- (n_x * n_y) * (x_bar - y_bar)^2 / ((n_x + n_y)*(n_x + n_y - 1))
  
  return(var_xy_clean + var_xy_error)
}

iterated_pooled_var <- function(mean_vec, sdev_vec, n_vec) {
  if(!all.equal(length(mean_vec), length(sdev_vec), length(n_vec))) {
    stop('Mean, std dev, and n vectors must all be equal length!')
  }
  if(length(mean_vec) == 1) {
    warning('Only one element - no need for pooled variance!')
    return(sdev_vec[1]^2)
  }
  ### initialize values for first in list
  mean_x <- mean_vec[1]; s_x <- sdev_vec[1]; n_x <- n_vec[1]
  for(i in 2:length(mean_vec)) { ## i <- 2
    mean_y <- mean_vec[i]
    s_y    <- sdev_vec[i]
    n_y    <- n_vec[i]
    var_out <- pooled_var(x_bar = mean_x, y_bar = mean_y, n_x = n_x, n_y = n_y, s_x = s_x, s_y = s_y)
  
    ### set up values for next iteration
    mean_x <- (mean_x * n_x + mean_y * n_y) / (n_x + n_y)
    s_x <- sqrt(var_out)
    n_x <- n_x + n_y
  }
  return(var_out)
}

### test that the function returns the correct variance value
# set.seed(42)
# n_vec <- c(1, 5, 10, 15)
# x_list <- list(rnorm(mean = 10, sd = 2, n = n_vec[1]),
#                rnorm(mean = 15, sd = 1, n = n_vec[2]),
#                rnorm(mean = 20, sd = 3, n = n_vec[3]),
#                rnorm(mean =  5, sd = 1, n = n_vec[4]))
# 
# ### initialize values for first term
# mean_vec <- sapply(x_list, mean)
# sdev_vec <- sapply(x_list, sd)
# n_vec    <- sapply(x_list, length)
# 
# var_out <- iterated_pooled_var(mean_vec, sdev_vec, n_vec)
# 
# var_check <- var(unlist(x_list))
# 
# var_check == var_out

```

```{r assemble taxon vuln maps to total maps}

tx_v_map_df <- data.frame(f = list.files(dirname(out_stem), full.names = TRUE,
                                         pattern = 'vuln_tx_.+.tif')) %>%
  mutate(t = str_extract(basename(f), paste0(taxa, collapse = '|')),
         s = str_extract(basename(f), paste0(strs, collapse = '|')),
         p = str_extract(basename(f), '_mean|_sdev|_nspp') %>% str_remove('_'))

r_to_df <- function(f) {
  r <- raster::raster(f)
  df <- data.frame(val = values(r),
                   cell_id = 1:ncell(r)) %>%
    filter(!is.na(val))
  return(df)
}

out_stem <- here_anx('vuln_maps/vuln_total/vuln_all_spp_by_str/vuln_all_spp_%s_%s.tif')
  ### format will be: stressor, parameter (mean, sd, nspp)

for(stressor in strs) {
  ### stressor <- strs[1]
  
  ### check if total stressor maps are complete
  outf_mean <- sprintf(out_stem, stressor, 'mean')
  outf_sdev <- sprintf(out_stem, stressor, 'sdev')
  outf_nspp <- sprintf(out_stem, stressor, 'nspp')
  
  if(all(file.exists(outf_mean, outf_sdev, outf_nspp))) {
    message('All rasters exist for stressor ', stressor, '... skipping!')
    next()
  }

  message('Processing mean, sd, nspp maps across all species for ', stressor, ' stressor...')
  str_tx_v_df <- tx_v_map_df %>%
    filter(s == stressor)
  mean_fs <- str_tx_v_df %>% filter(p == 'mean') %>% .$f
  sdev_fs <- str_tx_v_df %>% filter(p == 'sdev') %>% .$f
  nspp_fs <- str_tx_v_df %>% filter(p == 'nspp') %>% .$f
  
  message('... loading mean, sd, nspp maps for all taxa...')
  mean_df <- parallel::mclapply(mean_fs, mc.cores = 12, FUN = r_to_df) %>%
    setNames(taxa) %>%
    bind_rows(.id = 'taxon') %>%
    rename(v_mean = val)
  sdev_df <- parallel::mclapply(sdev_fs, mc.cores = 12, FUN = r_to_df) %>%
    setNames(taxa) %>%
    bind_rows(.id = 'taxon') %>%
    rename(v_sdev = val)
  nspp_df <- parallel::mclapply(nspp_fs, mc.cores = 12, FUN = r_to_df) %>%
    setNames(taxa) %>%
    bind_rows(.id = 'taxon') %>%
    rename(v_nspp = val)
  big_df <- mean_df %>%
    oharac::dt_join(sdev_df, by = c('taxon', 'cell_id'), type = 'full') %>%
    oharac::dt_join(nspp_df, by = c('taxon', 'cell_id'), type = 'full')
    
  message('... summarizing mean vulnerability map across all taxa...')
  all_spp_mean <- big_df %>%
    group_by(cell_id) %>%
    summarize(vuln_mean = sum(v_mean * v_nspp) / sum(v_nspp))
  message('... summarizing species richness map across all taxa...')
  all_spp_nspp <- big_df %>%
    group_by(cell_id) %>%
    summarize(vuln_nspp = sum(v_nspp))
  message('... summarizing standard deviation vulnerability map across all taxa...')
  system.time({
    ### how to speed this one up?
    all_spp_sdev <- big_df %>%
      group_by(cell_id) %>%
      summarize(vuln_sdev = sqrt(iterated_pooled_var(v_mean, v_sdev, v_nspp)))
  })
  
  message('... converting dataframes to rasters...')

  rast_mean <- map_to_mol(all_spp_mean, which = 'vuln_mean')
  rast_sd   <- map_to_mol(all_spp_sdev, which = 'vuln_sdev')
  rast_nspp <- map_to_mol(all_spp_nspp, which = 'vuln_nspp')
  
  message('... writing out rasters: ', 
          '\n    ', str_replace(outf_mean, '/home/shares/ohi/spp_vuln/', 'Mazu:'), 
          '\n    ', str_replace(outf_sdev, '/home/shares/ohi/spp_vuln/', 'Mazu:'), 
          '\n    ', str_replace(outf_nspp, '/home/shares/ohi/spp_vuln/', 'Mazu:'))

  writeRaster(rast_mean, outf_mean, overwrite = TRUE)
  writeRaster(rast_sd,   outf_sdev, overwrite = TRUE)
  writeRaster(rast_nspp, outf_nspp, overwrite = TRUE)
}

```


### FIX ALL THIS

```{r plot vuln by species by stressor, fig.height = 4, fig.width = 10}
focal_strs <- c('biomass', 'bycatch', 'plastic', 
                'nutrient', 'oa', 'water_temp',
                'light', 'noise', 'organic') %>%
  paste0(collapse = '|')
mean_fs <- list.files(here('_output/vuln_by_spp'), pattern = 'mean', full.names = TRUE)
# sd_fs   <- list.files(here('_output/vuln_by_spp'), pattern = 'sd', full.names = TRUE)

mean_fs <- mean_fs[str_detect(basename(mean_fs), focal_strs)]

mean_stack <- raster::stack(mean_fs) %>%
  setNames(str_remove(names(.), 'vuln_by_spp_'))
# sd_stack   <- raster::stack(sd_fs) %>%
#   setNames(str_remove(names(.), 'vuln_by_spp_'))

map_cols <- hcl.colors(n = 10)

plot(mean_stack, zlim = c(0, 1), col = map_cols,
     legend = FALSE, axes = FALSE)
# plot(sd_stack,   zlim = c(0, 1), legend = FALSE, axes = FALSE)
```

### By FE, unweighted

```{r vuln by FE iterating over stressors}

strs <- spp_vuln$stressor %>% unique() %>% sort()

out_stem <- here('_output/vuln_by_fe/vuln_by_fe_%s_%s.tif')
### unlink(list.files(here('_output/vuln_by_fe'), full.names = TRUE))

fe_df <- read_csv(here('_output/func_entities/species_fe.csv'))

am_vuln_fe <- am_vuln %>%
  oharac::dt_join(fe_df, by = 'species', type = 'inner') %>%
  select(am_sid, fe_id, stressor, score) %>%
  distinct()

for(s in strs) {
  ### s <- strs[1]
  if(file.exists(sprintf(out_stem, s, 'mean'))) {
    message('Rasters exist for stressor ', s, '... skipping!')
    next()
  }
  message('processing mean/sd vulnerability by species to stressor: ', s)
  
  am_vuln_str <- am_vuln_fe %>%
    filter(stressor == s)
  
  am_spp_vuln_cells <- am_spp_cells %>%
    oharac::dt_join(am_vuln_str, by = 'am_sid', type = 'inner')
  message('summarizing by FE in each cell...')
  result_df <- am_spp_vuln_cells %>%
    filter(!is.na(score)) %>%
    group_by(loiczid, fe_id) %>%
    ### first, summarize by FE per cell...
    summarize(score_mean1 = mean(score),
              # score_sd   = sd(score),
              .groups = 'drop')
  
  message('...then summarizing across all FEs in each cell...')
  result_df <- result_df %>%
    group_by(loiczid) %>%
    ### ... then average across all FEs
    summarize(score_mean = mean(score_mean1),
              # score_sd   = sqrt(sum(score_sd^2, na.rm = TRUE) / n()),
              # score_sd   = sd(score_mean1), ### this is deviation of mean among FEs
              .groups = 'drop')
    
  rast_mean <- map_to_hcaf(result_df, which = 'score_mean')
  # rast_sd   <- map_to_hcaf(result_df, which = 'score_sd')

  writeRaster(rast_mean, sprintf(out_stem, s, 'mean'), overwrite = TRUE)
  # writeRaster(rast_sd,   sprintf(out_stem, s, 'sd'), overwrite = TRUE)
}
```

#### Inclusion of species: vuln X am X fe

When applying vulnerability scores at the functional entity level, species must be accounted for in AquaMaps, vulnerability scores, and functional entity traits.  In this case, the number of included species is `r am_vuln_fe$am_sid %>% n_distinct()`.  Looking at the intersection of AquaMaps and functional traits only, we include `r fe_df %>% filter(species %in% am_spp_ids$sciname) %>% .$species %>% n_distinct()`.

```{r plot vuln by FE by stressor, fig.height = 4, fig.width = 10}
mean_fs <- list.files(here('_output/vuln_by_fe'), pattern = 'mean', full.names = TRUE)
# sd_fs   <- list.files(here('_output/vuln_by_fe'), pattern = 'sd', full.names = TRUE)

mean_fs <- mean_fs[str_detect(basename(mean_fs), focal_strs)]

mean_stack <- raster::stack(mean_fs) %>%
  setNames(str_remove(names(.), 'vuln_by_fe_'))
# sd_stack   <- raster::stack(sd_fs) %>%
#   setNames(str_remove(names(.), 'vuln_by_fe_'))

plot(mean_stack, zlim = c(0, 1), col = map_cols,
     legend = FALSE, axes = FALSE)
# plot(sd_stack,   zlim = c(0, 1), legend = FALSE, axes = FALSE)
```

### By FE, FV-weighted

Here, calculate mean stressor vulnerability for each functional entity, along with the functional vulnerability of each entity using $\left(\frac{1}{2}\right)^{n-1}$ (so for an FE represented by one species, functional vuln = $\left(\frac{1}{2}\right)^{0}$ 1; for an FE represented by 5 spp, $\left(\frac{1}{2}\right)^{4}$ = .0625; for an FE represented by 10 spp, $\left(\frac{1}{2}\right)^{9}$ = .002 etc).

```{r weighted vuln by FE iterating over stressors}

strs <- spp_vuln$stressor %>% unique() %>% sort()

message('Calculating functional vulnerability by FE and cell...')

out_stem <- here('_output/vuln_by_fe_weighted/vuln_wt_by_fe_%s_%s.tif')

### unlink(list.files(here('_output/vuln_by_fe_weighted'), full.names = TRUE))

for(s in strs) {
  ### s <- strs[2]
  if(file.exists(sprintf(out_stem, s, 'mean'))) {
    message('Rasters exist for stressor ', s, '... skipping!')
    next()
  }

  message('processing mean/sd vulnerability by species to stressor: ', s)

  if(!exists('am_spp_cells_fv')) {
    am_spp_cells_fv <- am_spp_cells %>%
      oharac::dt_join(am_vuln_fe %>% 
                        select(am_sid, fe_id) %>% distinct(), 
                      by = 'am_sid', type = 'inner') %>%
      group_by(loiczid, fe_id) %>%
      mutate(nspp_fe = n(), ### only one observation per am_sid per cell
             fv = 0.5^(nspp_fe - 1)) %>%
      ungroup()
  }

  am_vuln_str <- am_vuln_fe %>%
    filter(stressor == s) %>%
    select(-fe_id) %>%
    distinct()
  am_spp_vuln_cells <- am_spp_cells_fv %>%
    oharac::dt_join(am_vuln_str, by = c('am_sid'), type = 'inner')
  
  message('summarizing by FE in each cell...')
  result_df <- am_spp_vuln_cells %>%
    filter(!is.na(score)) %>%
    group_by(loiczid, fe_id, fv, nspp_fe) %>%
    ### first, summarize by FE per cell...
    summarize(score_mean1 = mean(score),
              # score_sd   = sd(score),
              .groups = 'drop')
  
  message('...then summarizing weighted mean across all FEs in each cell...')
  result_df <- result_df %>%
    group_by(loiczid) %>%
    ### ... then average across all FEs
    summarize(score_mean = Hmisc::wtd.mean(score_mean1, weights = fv),
              # score_sd   = sqrt(sum(score_sd^2 * fv, na.rm = TRUE) / sum(fv)),
              # score_sd   = sqrt(Hmisc::wtd.var(score_mean1, weights = fv)),
                ### weighted std dev among mean scores for each FE
              n_spp      = sum(nspp_fe),
              .groups = 'drop')
    
  rast_mean <- map_to_hcaf(result_df, which = 'score_mean')
  # rast_sd   <- map_to_hcaf(result_df, which = 'score_sd')

  writeRaster(rast_mean, sprintf(out_stem, s, 'mean'), overwrite = TRUE)
  # writeRaster(rast_sd,   sprintf(out_stem, s, 'sd'), overwrite = TRUE)
}
```

```{r plot weighted vuln by FE by stressor, fig.height = 4, fig.width = 10}
mean_fs <- list.files(here('_output/vuln_by_fe_weighted'), pattern = 'mean', full.names = TRUE)
# sd_fs   <- list.files(here('_output/vuln_wt_by_fe'), pattern = 'sd', full.names = TRUE)

mean_fs <- mean_fs[str_detect(basename(mean_fs), focal_strs)]

mean_stack <- raster::stack(mean_fs) %>%
  setNames(str_remove(names(.), 'vuln_wt_by_fe_'))
# sd_stack   <- raster::stack(sd_fs) %>%
#   setNames(str_remove(names(.), 'vuln_wt_by_fe_'))

plot(mean_stack, zlim = c(0, 1), col = map_cols,
     legend = FALSE, axes = FALSE)
# plot(sd_stack,   zlim = c(0, 1), legend = FALSE, axes = FALSE)
```