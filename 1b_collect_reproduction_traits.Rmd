---
title: 'Collect reproductivity traits'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/src/templates/ohara_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = TRUE, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

library(oharac)
oharac::setup()
library(rfishbase)
library(ggfortify) ### for PCA plots
source(here('fb_slb_fxns.R'))

### used for joining and gapfilling
spp_from_worms <- get_worms()

```

# Summary

Gather data on reproductive traits from FishBase and the species vulnerability project: Max fecundity, generation time, parental care (pre-birth/hatch), parental dependence (post-birth/hatch), PLD.  Gapfill using downfill and upstream-downstream gapfill methodology.  Finally use PCA to reduce dimensionality across multiple traits, keeping the first two components.

# Data

This script will use processed valid species traits from the species vulnerability project, plus FishBase and SeaLifeBase.

FishBase is a scientific database, and this has the implication - among others - that its use and the use of its contents are free as long as due credit is given.

This may be done at different levels, for which we suggest different forms of citations:

* when referring to FishBase concepts and design, cite its architects (Froese and Pauly 2000);
* when referring to a set of values extracted from a FishBase table, cite the author(s) of the original data, e.g., "Houde and Zastrow (1993)", or "Welcomme (1988)". To help us track the use of FishBase in the literature, we would appreciate your also citing Froese and Pauly (2000) in an appropriate part of your text, as the source of the information;
* when discussing the features of a FishBase table, cite the section documenting that table, e.g., "Sa-a et al. (2000)."

## References

* Froese, R. and D. Pauly, Editors. 2000. FishBase 2000: concepts, design and data sources. ICLARM, Los Baños, Laguna, Philippines. 344 p.
* Houde, E.D. and C.E. Zastrow. 1993. Ecosystem- and taxon-specific dynamic energetics properties of fish larvae assemblages. Bull. Mar. Sci. 53(2):290-335.
* Sa-a, P., M.L. Palomares and D. Pauly. 2000. The FOOD ITEMS table, p. 182-188. In R. Froese and D. Pauly (eds.) FishBase 2000: concepts, design and data sources. ICLARM, Los Baños, Laguna, Philippines. 344 p.
* Welcomme, R.L. 1988. International introductions of inland aquatic species. FAO Fish. Tech. Pap. 294, 318 p.
* Butt, N. et al. 2021. 

# Methods

## Age at maturity: Read in data

Read in data from vulnerability project and fishbase/sealifebase.  FB/SLB have many NAs for these, but let's see how far we can get.  Otherwise, expand with data from species vulnerability trait data.

```{r}
fields <- c('age', 'tm')

mat_df_raw <- get_fb_slb(rfishbase::maturity,
                       keep_cols = fields, keep_fxn = contains,
                       drop_cols = '_ref', drop_fxn = ends_with) %>%
  select(db, spec_code, species, tm, age_mat_min, age_mat_min2) %>%
  filter(!is.na(tm) | !is.na(age_mat_min) | !is.na(age_mat_min2))


lm_amm <- lm(age_mat_min ~ tm, data = mat_df_raw); coef_amm <- lm_amm$coefficients[2]
# summary(lm_amm)
### slope = .76, p << .001, adj.R^2 = .67
lm_amm2 <- lm(age_mat_min2 ~ tm, data = mat_df_raw); coef_amm2 <- lm_amm2$coefficients[2]
# summary(lm_amm2)
### slope = 1.43, p << .001, adj.R^2 = .80

mat_df <- mat_df_raw %>%
  mutate(t_maturity = case_when(!is.na(tm) ~ tm,
                                !is.na(age_mat_min2) ~ age_mat_min2 / coef_amm2,
                                TRUE ~ age_mat_min / coef_amm)) %>%
  select(db, spec_code, species, t_maturity) %>%
  group_by(db, spec_code, species) %>%
  summarize(age_mat = mean(t_maturity), .groups = 'drop') %>%
  right_join(spp_from_worms, by = 'species')

table(mat_df$db)
```

Even with all this, we get only 1576 distinct species, at least some of which are freshwater.

```{r}
age_mat_vuln <- get_vuln_traits() %>%
  filter(trait == 'age_to_1st_reproduction_generation_time') %>%
  mutate(trait_value = factor(trait_value,
                              levels = c('<1yr', '1-5yrs', '5-10yrs', '10-20yrs', '>20yrs')),
         bin = as.integer(trait_value))

age_mat_vuln_gf <- downfill(age_mat_vuln)
```

### Calculate bin values

Use the numeric age values to assign a mean age_mat value to each of the categorical bins.  The histogram looks a little more log-normal than normal... Filter out only those observations that match with the range, then log transform and calc the mean/sd.

``` {r}
### compare vulnerability data to fb/slb data

vuln_and_fb <- age_mat_vuln_gf %>%
  full_join(mat_df)

compare_df <- vuln_and_fb %>% 
  filter(!is.na(trait_value) & !is.na(age_mat)) %>%
  mutate(match = (bin == 1 & age_mat < 1) |
                 (bin == 2 & between(age_mat, 1, 5)) |
                 (bin == 3 & between(age_mat, 5, 10)) |
                 (bin == 4 & between(age_mat, 10, 20)) |
                 (bin == 5 & age_mat >= 20))

hist(log(compare_df$age_mat))

### 207 spp with values in both
ggplot(compare_df, aes(x = trait_value, y = age_mat, color = match)) +
  geom_point()

summary(lm(bin ~ log10(age_mat), data = compare_df %>% filter(match)))

summary_bins <- compare_df %>%
  filter(match) %>%
  group_by(trait_value) %>%
  summarize(mean_log_age_mat = mean(log10(age_mat)),
            sd_log_age_mat = sd(log10(age_mat)))

novel_df <- vuln_and_fb %>% 
  filter(is.na(trait_value) & !is.na(age_mat))
### 1408 spp with FB/SLB age to maturity but no vuln age to maturity

gen_time_df <- vuln_and_fb %>%
  left_join(summary_bins, by = 'trait_value') %>%
  mutate(log_gen_time = ifelse(!is.na(age_mat), log10(age_mat), mean_log_age_mat)) %>%
  group_by(db, spec_code, kingdom, phylum, class, order, family, genus, species, gapfill, match_rank) %>%
  summarize(log_gen_time = mean(log_gen_time, na.rm = TRUE), 
            sd_log_gen_time = sqrt(sum(sd_log_age_mat^2, na.rm = TRUE)), .groups = 'drop')

gen_time_gf <- gen_time_df %>%
  gapfill_up_down(col = 'log_gen_time')
```

## Fecundity

Read in data from vulnerability project and fishbase/sealifebase.  Examine potential for variables to be used to gapfill for max fecundity.  Min and max both have >2400 observations; mean has 133.

```{r}
fields <- c('fecun')
fecund_df_raw <- get_fb_slb(fxn = fecundity,
                     keep_cols = fields, keep_fxn = contains,
                     drop_cols = '_ref', drop_fxn = ends_with) %>%
  select(db, spec_code, species, starts_with('fecun'))
# summary(fecund_df_raw)
# fecund_df_raw %>% summarize(across(starts_with('fecun'), .fns = ~sum(!is.na(.x))))

lm_fec1 <- lm(fecundity_max ~ fecundity_min, data = fecund_df_raw); coef_fec1 <- lm_fec1$coefficients[2]
# summary(lm_fec1)
### slope = 2.92, p << .001, adj.R^2 = .83
lm_fec2 <- lm(fecundity_max ~ fecundity_mean, data = fecund_df_raw); coef_fec2 <- lm_fec2$coefficients[2]
# summary(lm_fec2)
### slope = 1.15, p << .001, adj.R^2 = .95

fecund_df <- fecund_df_raw %>%
  mutate(max_fecundity = case_when(!is.na(fecundity_max) ~ fecundity_max,
                             !is.na(fecundity_mean) ~ fecundity_mean * coef_fec2,
                             !is.na(fecundity_min) ~ fecundity_min * coef_fec1,
                             TRUE ~ NA_real_)) %>%
  select(db, spec_code, species, max_fecundity) %>%
  group_by(db, spec_code, species) %>%
  summarize(max_fecundity = mean(max_fecundity), .groups = 'drop') %>%
  right_join(spp_from_worms, by = 'species')

table(fecund_df$db)
fecund_df %>% filter(!is.na(max_fecundity)) %>% n_distinct(.$species)

```

Even with all this, we get only 1161 distinct species, guessing some of which are freshwater.

```{r}
f_vals <- c('<1', '1-2' , '2-5', '5-10', '10-20', '20-50', '50-100', '100-1000', '1000-10000', '>10000')      

fecund_vuln <- get_vuln_traits() %>%
  filter(trait == 'fecundity') %>%
  mutate(trait_value = factor(trait_value,
                              levels = f_vals),
         bin = as.integer(trait_value))

fecund_vuln_gf <- downfill(fecund_vuln)
```

### Calculate bin values

Use the numeric fecundity values to assign a mean max_fecundity value to each of the categorical bins.  Even log-transformed, there is still a lot of skew.  Filter out only those observations that match with the range, then log transform and calc the mean/sd.

``` {r}
### compare vulnerability data to fb/slb data

vuln_and_fb <- fecund_vuln_gf %>%
  full_join(fecund_df)

# f_vals <- c('<1', '1-2' , '2-5', '5-10', '10-20', '20-50', '50-100', '100-1000', '1000-10000', '>10000')      
compare_df <- vuln_and_fb %>% 
  filter(!is.na(trait_value) & !is.na(max_fecundity)) %>%
  mutate(match = (bin == 1 & max_fecundity <= 1) |
                 (bin == 2 & between(max_fecundity, 1, 2)) |
                 (bin == 3 & between(max_fecundity, 2, 5)) |
                 (bin == 4 & between(max_fecundity, 5, 10)) |
                 (bin == 5 & between(max_fecundity, 10, 20)) |
                 (bin == 6 & between(max_fecundity, 20, 50)) |
                 (bin == 7 & between(max_fecundity, 50, 100)) |
                 (bin == 8 & between(max_fecundity, 100, 1000)) |
                 (bin == 9 & between(max_fecundity, 1000, 10000)) |
                 (bin == 10 & max_fecundity >= 10000))

hist(log(compare_df$max_fecundity))

### 207 spp with values in both
ggplot(compare_df, aes(x = trait_value, y = max_fecundity, color = match)) +
  geom_jitter() +
  scale_y_log10()

summary(lm(bin ~ log10(max_fecundity), data = compare_df %>% filter(match)))

summary_bins <- compare_df %>%
  filter(match) %>%
  group_by(trait_value) %>%
  summarize(mean_log_max_fecundity = mean(log10(max_fecundity)),
            sd_log_max_fecundity = sd(log10(max_fecundity)))

novel_df <- vuln_and_fb %>% 
  filter(is.na(trait_value) & !is.na(max_fecundity))
### 952 spp with FB/SLB max fecundity but no vuln fecundity

max_fecund_df <- vuln_and_fb %>%
  left_join(summary_bins, by = 'trait_value') %>%
  mutate(log_max_fecund = ifelse(!is.na(max_fecundity), log10(max_fecundity), mean_log_max_fecundity)) %>%
  group_by(db, spec_code, kingdom, phylum, class, order, family, genus, species, gapfill, match_rank) %>%
  summarize(log_max_fecund = mean(log_max_fecund, na.rm = TRUE), 
            sd_log_max_fecund = sqrt(sum(sd_log_max_fecundity^2, na.rm = TRUE)), .groups = 'drop')


max_fecund_gf <- max_fecund_df %>%
  gapfill_up_down(col = 'log_max_fecund')
```

## Parental investment

Read in data from vulnerability project and fishbase/sealifebase.  Here we have data on parental investment (maternal/paternal/both/neither) and protection mode (bearers/guarders/non-guarders).  Assign protection mode from bearers (high) to non-guarders (low).  Because the parental investment score here only covers FishBase, and is not comparable to that in the vulnerability traits data (which is closer to the protection trait), let's skip it in favor of the post-birth dependence trait in the vulnerability traits data.

```{r}
fields <- c('parental', 'guild')

reprod_df_raw <- get_fb_slb(fxn = reproduction,
                     keep_cols = fields, keep_fxn = contains,
                     drop_cols = '_ref', drop_fxn = ends_with)
# summary(reprod_df_raw)

# x <- reprod_df_raw %>% filter(!is.na(rep_guild1) | !is.na(parental_care))

# parent_df <- reprod_df_raw %>%
#   mutate(parental_score = case_when(parental_care == 'none' ~ 0,
#                                   str_detect(parental_care, 'aternal') ~ 1,
#                                   parental_care == 'biparental' ~ 2)) %>%
#   select(db, spec_code, species, parental_score) %>%
#   group_by(db, spec_code, species) %>%
#   summarize(parental_score = mean(parental_score), .groups = 'drop') %>%
#   right_join(spp_from_worms, by = 'species')
# 
# parent_df %>% filter(!is.na(parental_score)) %>% select(db, parental_score) %>% table()

protect_df <- reprod_df_raw %>%
  mutate(rep_guild1 = factor(rep_guild1, levels = c('nonguarders', 'guarders', 'bearers')),
         protect_score = as.integer(rep_guild1)) %>%
  select(db, spec_code, species, protect_score) %>%
  group_by(db, spec_code, species) %>%
  summarize(protect_score = mean(protect_score), .groups = 'drop') %>%
  right_join(spp_from_worms, by = 'species')

protect_df %>% filter(!is.na(protect_score)) %>% select(db, protect_score) %>% table()

```

For parental investment: We get 5042 distinct species, all of which are from FishBase, guessing some of which are freshwater.  For protection mode, we get 21890 species across both FB and SLB.

For the vulnerability data, parental investment is based on: (egg-layer unattended, egg-layer, live birth/egg care, spawner) - which seems comparable to protection mode above.  Post-birth/hatching parental dependence is a time scale: less than a week up to more than a year.

```{r}
parent_vuln <- get_vuln_traits() %>%
  filter(str_detect(trait, 'parental_investment')) %>%
  mutate(parent_score = case_when(str_detect(trait_value, 'spawn|unattend') ~ 0,
                                trait_value == 'egg-layer' ~ 1,
                                trait_value == 'live birth/egg care' ~ 2))

parent_vuln_gf <- downfill(parent_vuln)

depend_vuln <- get_vuln_traits() %>%
  filter(trait == 'post_birth_hatching_parental_dependence') %>%
  mutate(trait_value = factor(trait_value, levels = c('na', '<week', 'week-month', 'month-year', '>year')),
         depend_score = as.double(trait_value) - 1)
           ### so "na" is 0 dependence, i.e., no post-birth care

depend_vuln_gf <- downfill(depend_vuln)
```

### Compare datasets

First compare the FB/SLB parental protection traits to those in the vulnerability dataset.  It appears that the `protect_score` from FishBase captures more differences in the middle values, so use that as the preferred dataset, filling in with `parent_score` from the vulnerability traits.

Here we also incorporate length of post-birth/hatching dependence from the vulnerability traits.

```{r}
vuln_and_fb <- protect_df %>%
  full_join(parent_vuln_gf)

ggplot(vuln_and_fb, aes(x = parent_score, y = protect_score)) +
  geom_jitter()

parental_protect_df <- vuln_and_fb %>%
  mutate(protect_score = ifelse(is.na(protect_score), parent_score, protect_score)) %>%
  group_by(db, spec_code, kingdom, phylum, class, order, family, genus, species, gapfill, match_rank) %>%
  summarize(protect_score = mean(protect_score, na.rm = TRUE), .groups = 'drop')

parental_protect_gf <- parental_protect_df %>%
  gapfill_up_down(col = 'protect_score')

parental_depend_gf <- depend_vuln_gf %>%
  group_by(class, order, family, genus, species, gapfill, match_rank) %>%
  summarize(depend_score = mean(depend_score, na.rm = TRUE), .groups = 'drop') %>%
  full_join(get_worms()) %>%
  gapfill_up_down(col = 'depend_score')

```




## Planktonic larval duration

From the vulnerability traits, we can identify PLD as a potential variable for discerning functional groups.

```{r}
pld_vals <- c('not larvae', '<1day', '<1week', '<1month', '<4months', '4months-1yr', '>1yr')

pld_vuln <- get_vuln_traits() %>%
  filter(str_detect(trait, 'planktonic_larval_duration')) %>%
  mutate(trait_value = factor(trait_value, levels = pld_vals),
         pld_score = as.integer(trait_value) - 1) %>%
  group_by(taxon, spp_gp) %>%
  summarize(pld_score = mean(pld_score, na.rm = TRUE), .groups = 'drop')

pld_vuln_downfill <- downfill(pld_vuln)

pld_vuln_gf <- pld_vuln_downfill %>%
  full_join(protect_df %>% select(-protect_score)) %>%
  gapfill_up_down(col = 'pld_score')

```

## Put them all together and PCA

```{r}
repr_df_all <- pld_vuln_gf %>%
  bind_rows(gen_time_gf, max_fecund_gf, parental_protect_gf, parental_depend_gf) %>%
  select(-db, -spec_code) %>%
  distinct()

repr_df_wide <- repr_df_all %>%
  group_by(species) %>%
  mutate(gf_level = mean(gf_level)) %>% ### if any unfilled, let be NA
  ungroup() %>%
  select(-sd, -nspp) %>%
  spread(trait, value) %>%
  distinct() 

repr_df_drop_na <- repr_df_wide %>%
  drop_na()

repr_pca <- repr_df_drop_na %>%
  select(where(is.numeric)) %>%
  scale() %>%
  prcomp()

autoplot(repr_pca,
         data = repr_df_drop_na,
         loadings = TRUE,
         colour = 'class',
         loadings.label = TRUE,
         loadings.colour = "black",
         loadings.label.colour = "black",
         loadings.label.vjust = -0.5
         ) +
  scale_color_viridis_d() +
  theme_minimal()

# Variance explained by each PC
screeplot(repr_pca, type = "lines")

# See the loadings (weighting for each principal component)
repr_pca$rotation %>% round(3)

round(repr_pca$sdev^2/sum(repr_pca$sdev^2)*100)


```

From this it appears that the first two principal components account for ~61% of the explainable variance in the data, one driven in large part by parental dependence (post-birth), and the other driven in large part by parental protection (pre-birth).

Write out the results, keeping gapfills to order level or below:
```{r}
repr_pca_df <- repr_df_drop_na %>%
  select(species) %>%
  bind_cols(as.data.frame(repr_pca$x[, 1:2])) %>%
  rename(repr_pc1 = PC1, repr_pc2 = PC2)

repr_out_df <- repr_df_wide %>%
  select(species, gf_level,
         depend_score, log_gen_time, log_max_fecund, pld_score, protect_score) %>%
  distinct() %>%
  left_join(repr_pca_df) %>%
  filter(gf_level <= 4)

write_csv(repr_out_df, here('_data/traits_grouping/trait_reproduction_raw.csv'))

repr_pc1_df <- repr_out_df %>%
  mutate(trait = 'repr_pc1') %>%
  select(species, gf_level, trait, value = repr_pc1)
write_csv(repr_pc1_df, here('_data/traits_grouping/trait_repr_pc1.csv'))
repr_pc2_df <- repr_out_df %>%
  mutate(trait = 'repr_pc2') %>%
  select(species, gf_level, trait, value = repr_pc2)
write_csv(repr_pc2_df, here('_data/traits_grouping/trait_repr_pc2.csv'))

```

